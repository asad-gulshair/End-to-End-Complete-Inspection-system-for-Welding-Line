<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RICI Industries - AI Powered Inspection System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Primary Color Palette - Professional Blues */
            --primary-dark: #1a365d;
            --primary-main: #2563eb;
            --primary-light: #3b82f6;
            --primary-lighter: #93c5fd;
            
            /* Secondary Color Palette - Accent Colors */
            --secondary-orange: #ea580c;
            --secondary-emerald: #059669;
            --secondary-purple: #7c3aed;
            --secondary-rose: #e11d48;
            
            /* Neutral Colors */
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            
            /* Status Colors */
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: var(--primary-main);
            
            /* Gradients */
            --gradient-primary: linear-gradient(135deg, var(--primary-main) 0%, var(--primary-dark) 100%);
            --gradient-secondary: linear-gradient(135deg, var(--secondary-orange) 0%, var(--secondary-rose) 100%);
            --gradient-success: linear-gradient(135deg, var(--secondary-emerald) 0%, #34d399 100%);
            --gradient-backdrop: linear-gradient(135deg, #f0f9ff 0%, #e0e7ff 100%);
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
            
            /* Border Radius */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --radius-2xl: 1.5rem;
            --radius-full: 9999px;
            
            /* Transitions */
            --transition-fast: all 0.15s ease-in-out;
            --transition-normal: all 0.3s ease-in-out;
            --transition-slow: all 0.5s ease-in-out;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--gradient-backdrop);
            color: var(--gray-800);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        /* Header Styles */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--gray-200);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .company-logo {
            width: 3.5rem;
            height: 3.5rem;
            background: var(--gradient-primary);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.25rem;
            box-shadow: var(--shadow-md);
        }
        
        .company-info h2 {
            color: var(--gray-800);
            font-size: 1.375rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }
        
        .ai-badge {
            background: var(--gradient-secondary);
            color: white;
            padding: 0.375rem 0.875rem;
            border-radius: var(--radius-full);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: var(--shadow-sm);
        }
        
        .nav-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .ai-indicator {
            width: 2.5rem;
            height: 2.5rem;
            background: var(--gradient-success);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            box-shadow: var(--shadow-md);
        }
        
        .status-text {
            color: var(--gray-600);
            font-weight: 500;
            font-size: 0.875rem;
        }
        
        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 1.5rem;
        }
        
        /* Hero Section */
        .hero {
            text-align: center;
            margin-bottom: 4rem;
        }
        
        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: var(--primary-dark);
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, var(--primary-main), var(--secondary-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.1;
        }
        
        .hero p {
            font-size: 1.25rem;
            color: var(--gray-600);
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.7;
        }
        
        /* Feature Cards */
        .feature-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }
        
        .feature-card {
            background: white;
            border-radius: var(--radius-2xl);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--gray-100);
            transition: var(--transition-normal);
            position: relative;
            overflow: hidden;
        }
        
        .feature-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }
        
        .feature-card.weld::before {
            background: var(--gradient-primary);
        }
        
        .feature-card.coating::before {
            background: var(--gradient-secondary);
        }
        
        .feature-card.flange::before {
            background: var(--gradient-success);
        }
        
        .feature-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-2xl);
        }
        
        .card-icon {
            width: 4rem;
            height: 4rem;
            margin: 0 auto 1.5rem;
            border-radius: var(--radius-xl);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .card-icon.weld {
            background: var(--gradient-primary);
        }
        
        .card-icon.coating {
            background: var(--gradient-secondary);
        }
        
        .card-icon.flange {
            background: var(--gradient-success);
        }
        
        .feature-card h3 {
            color: var(--gray-800);
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .feature-card p {
            color: var(--gray-600);
            text-align: center;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .card-features {
            list-style: none;
            margin-bottom: 2rem;
        }
        
        .card-features li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            color: var(--gray-600);
            font-size: 0.875rem;
        }
        
        .card-features .checkmark {
            width: 1.25rem;
            height: 1.25rem;
            background: var(--success);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            flex-shrink: 0;
        }
        
        .btn {
            width: 100%;
            padding: 0.875rem 1.5rem;
            border: none;
            border-radius: var(--radius-lg);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-normal);
            text-transform: uppercase;
            letter-spacing: 0.025em;
            box-shadow: var(--shadow-md);
        }
        
        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--gradient-secondary);
            color: white;
        }
        
        .btn-success {
            background: var(--gradient-success);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-sm);
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(8px);
        }
        
        .modal-content {
            background: white;
            margin: 2% auto;
            padding: 0;
            border-radius: var(--radius-2xl);
            width: 95%;
            max-width: 1000px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-2xl);
        }
        
        .modal-header {
            padding: 2rem;
            border-bottom: 1px solid var(--gray-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        .modal-header.weld {
            background: linear-gradient(135deg, var(--primary-main), var(--primary-dark));
            color: white;
            border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        }
        
        .modal-header.coating {
            background: linear-gradient(135deg, var(--secondary-orange), var(--secondary-rose));
            color: white;
            border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        }
        
        .modal-header.flange {
            background: linear-gradient(135deg, var(--secondary-emerald), #34d399);
            color: white;
            border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        }
        
        .modal-title {
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .close {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: var(--radius-full);
            font-size: 1.25rem;
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ‚úÖ VALIDATION BANNERS */
.validation-failed-banner {
    background: linear-gradient(135deg, #fee2e2, #fecaca);
    border: 3px solid #ef4444;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
    box-shadow: 0 10px 25px rgba(239, 68, 68, 0.2);
    animation: shake 0.5s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.validation-icon {
    font-size: 3.5rem;
    flex-shrink: 0;
    animation: pulse 2s infinite;
}

.validation-content {
    flex: 1;
}

.validation-content h4 {
    color: #991b1b;
    margin: 0 0 1rem 0;
    font-size: 1.5rem;
    font-weight: 700;
}

.validation-actions {
    background: white;
    padding: 1.5rem;
    border-radius: 12px;
    border-left: 4px solid #ef4444;
    margin-top: 1rem;
}

.validation-actions strong {
    color: #991b1b;
    display: block;
    margin-bottom: 0.75rem;
    font-size: 1.125rem;
}

.validation-actions ul {
    margin: 0;
    padding-left: 1.5rem;
    color: #7f1d1d;
    line-height: 1.8;
}

.validation-actions li {
    margin-bottom: 0.5rem;
}

.validation-actions li strong {
    display: inline;
    font-size: 1rem;
}
        
        .close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }
        
        .modal-body {
            padding: 2rem;
        }
        
        /* Detection Type Selector */
        .detection-selector {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 0.5rem;
            background: var(--gray-50);
            border-radius: var(--radius-xl);
        }
        
        .detection-type-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius-lg);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            background: transparent;
            color: var(--gray-600);
        }
        
        .detection-type-btn.active {
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .detection-type-btn.weld.active {
            background: var(--gradient-primary);
        }
        
        .detection-type-btn.coating.active {
            background: var(--gradient-secondary);
        }
        
        .detection-type-btn.flange.active {
            background: var(--gradient-success);
        }
        
        /* Upload Area */
        .upload-area {
            border: 3px dashed var(--gray-300);
            border-radius: var(--radius-xl);
            padding: 3rem;
            text-align: center;
            margin-bottom: 2rem;
            background: var(--gray-50);
            transition: var(--transition-normal);
            cursor: pointer;
        }
        
        .upload-area.weld {
            border-color: var(--primary-light);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05), rgba(59, 130, 246, 0.05));
        }
        
        .upload-area.coating {
            border-color: var(--secondary-orange);
            background: linear-gradient(135deg, rgba(234, 88, 12, 0.05), rgba(225, 29, 72, 0.05));
        }
        
        .upload-area.flange {
            border-color: var(--secondary-emerald);
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.05), rgba(52, 211, 153, 0.05));
        }
        
        .upload-area:hover {
            border-style: solid;
            transform: scale(1.02);
        }
        
        .upload-area.weld:hover {
            border-color: var(--primary-main);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(59, 130, 246, 0.1));
        }
        
        .upload-area.coating:hover {
            border-color: var(--secondary-rose);
            background: linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(225, 29, 72, 0.1));
        }
        
        .upload-area.flange:hover {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(52, 211, 153, 0.1));
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--gray-400);
        }
        
        .upload-area h3 {
            color: var(--gray-700);
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .upload-area p {
            color: var(--gray-500);
            font-size: 0.875rem;
        }
        
        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem;
            border: 1px solid var(--gray-200);
            background: white;
            border-radius: var(--radius-lg);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-light);
        }
        
        .action-btn.primary {
            background: var(--gradient-primary);
            color: white;
            border-color: transparent;
        }
        
        .action-btn.secondary {
            background: var(--gradient-secondary);
            color: white;
            border-color: transparent;
        }
        
        .action-btn.success {
            background: var(--gradient-success);
            color: white;
            border-color: transparent;
        }

        /* Keep control buttons always above the video */

        .action-buttons {
            position: relative;
            z-index: 10;
        }
        
         
        .distance-info-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    margin: 1.5rem 0;
    border-left: 4px solid;
}

.distance-info-card.excellent { border-left-color: #10b981; }
.distance-info-card.good { border-left-color: #22c55e; }
.distance-info-card.fair { border-left-color: #f59e0b; }
.distance-info-card.poor { border-left-color: #ef4444; }

.distance-info-card h5 {
    margin: 0 0 1rem 0;
    color: #374151;
    font-size: 1.125rem;
}

.distance-metric {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.distance-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: #2563eb;
}

.distance-label {
    font-size: 1.125rem;
    color: #6b7280;
}

.quality-indicator {
    display: inline-block;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: 1rem;
}

.quality-indicator.quality-excellent {
    background: #d1fae5;
    color: #065f46;
}

.quality-indicator.quality-good {
    background: #d1fae5;
    color: #047857;
}

.quality-indicator.quality-fair {
    background: #fef3c7;
    color: #92400e;
}

.quality-indicator.quality-poor {
    background: #fee2e2;
    color: #991b1b;
}

.distance-warning {
    padding: 0.75rem;
    background: #f9fafb;
    border-radius: 6px;
    color: #374151;
    margin-bottom: 0.75rem;
    font-size: 0.875rem;
}

.distance-recommendation {
    padding: 0.75rem;
    background: #eff6ff;
    border-radius: 6px;
    color: #1e40af;
    font-size: 0.875rem;
    border-left: 3px solid #3b82f6;
}



        /* Detection Area */
        .detection-area {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-radius: var(--radius-xl);
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-full);
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            margin-bottom: 1rem;
        }
        
        .status-ready {
            background: var(--gray-100);
            color: var(--gray-600);
        }
        
        .status-active {
            background: var(--success);
            color: white;
            animation: pulse 2s infinite;
        }
        
        .status-processing {
            background: var(--warning);
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .status-error {
            background: var(--error);
            color: white;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #video, #canvas, .preview-image {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
        }
        
        .placeholder {
            color: var(--gray-400);
            font-size: 1.125rem;
        }
        
        /* Results Panel */
        .results-panel {
            background: white;
            border-radius: var(--radius-xl);
            padding: 2rem;
            margin-top: 2rem;
            border: 1px solid var(--gray-200);
            box-shadow: var(--shadow-md);
        }
        
        .results-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gray-100);
        }
        
        .results-header h3 {
            color: var(--gray-800);
            font-size: 1.375rem;
            font-weight: 700;
        }
        
        .results-icon {
            width: 2rem;
            height: 2rem;
            background: var(--gradient-primary);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.875rem;
        }
        
        .defect-list {
            background: var(--gray-50);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            min-height: 200px;
        }
        
        .defect-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: white;
            border-radius: var(--radius-md);
            margin-bottom: 1rem;
            border: 1px solid var(--gray-200);
            box-shadow: var(--shadow-sm);
        }
        
        .defect-item:last-child {
            margin-bottom: 0;
        }
        
        .defect-info {
            flex: 1;
        }
        
        .defect-type {
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: 0.25rem;
        }
        
        .defect-details {
            font-size: 0.875rem;
            color: var(--gray-600);
            margin-bottom: 0.25rem;
        }
        
        .defect-location {
            font-size: 0.75rem;
            color: var(--gray-500);
        }
        
        .defect-count {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        
        .count-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-800);
        }
        
        .severity-badge {
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .severity-high {
            background: var(--error);
            color: white;
        }
        
        .severity-medium {
            background: var(--warning);
            color: white;
        }
        
        .severity-low {
            background: var(--success);
            color: white;
        }
        
        .empty-state {
            text-align: center;
            color: var(--gray-400);
            font-style: italic;
            padding: 2rem;
        }
        
        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .export-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: var(--radius-md);
            color: var(--gray-700);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-normal);
            flex: 1;
            min-width: 120px;
            justify-content: center;
        }
        
        .export-btn:hover {
            background: var(--gray-50);
            border-color: var(--gray-400);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        
        /* AI Insights Panel */
        .ai-insights {
            background: linear-gradient(135deg, var(--gray-50), var(--gray-100));
            border: 1px solid var(--gray-200);
            border-radius: var(--radius-xl);
            padding: 2rem;
            margin-top: 2rem;
        }
        
        .insights-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .insights-icon {
            width: 2.5rem;
            height: 2.5rem;
            background: var(--gradient-primary);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.125rem;
        }
        
        .insights-header h4 {
            color: var(--gray-800);
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .insights-content {
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            color: var(--gray-700);
            line-height: 1.6;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-full);
            font-size: 0.75rem;
            font-weight: 600;
            z-index: 1001;
            box-shadow: var(--shadow-lg);
        }
        
        .connected {
            background: var(--success);
            color: white;
        }
        
        .disconnected {
            background: var(--error);
            color: white;
            animation: pulse 2s infinite;
        }
        
        /* Utilities */
        .hidden {
            display: none !important;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .feature-cards {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .modal-content {
                width: 98%;
                margin: 1% auto;
            }
            
            .modal-body {
                padding: 1rem;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .export-buttons {
                flex-direction: column;
            }
            
            .detection-selector {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .nav {
                padding: 1rem;
            }
            
            .main-content {
                padding: 2rem 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .hero h1 {
                font-size: 2rem;
            }
            
            .modal-header {
                padding: 1.5rem;
            }
            
            .modal-title {
                font-size: 1.5rem;
            }
            
            .upload-area {
                padding: 2rem 1rem;
            }
        }

        /* Enhanced styles for live detection results with snapshots */
           .live-results-header {
               display: flex;
               justify-content: space-between;
               align-items: center;
               margin-bottom: 1rem;
               padding: 1rem;
               background: linear-gradient(135deg, #ef4444, #dc2626);
               border-radius: 12px;
               color: white;
        }

           .live-results-header h4 {
               margin: 0;
               font-weight: 600;
               font-size: 1.25rem;
        }

           .live-indicator {
               background: rgba(255, 255, 255, 0.2);
               color: white;
               padding: 0.5rem 1rem;
               border-radius: 20px;
               font-size: 0.875rem;
               font-weight: 600;
               animation: pulse 2s infinite;
               backdrop-filter: blur(10px);
        }

           /* Enhanced defect items for live detection with snapshots */
           .defect-item-enhanced {
               display: flex;
               align-items: center;
               gap: 1.5rem;
               padding: 1.5rem;
               background: white;
               border-radius: 12px;
               margin-bottom: 1rem;
               box-shadow: 0 4px 12px rgba(0,0,0,0.1);
               border-left: 4px solid var(--primary-main);
               transition: transform 0.2s ease;
        }

          .defect-item-enhanced:hover {
               transform: translateY(-2px);
               box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

           .defect-main-info {
               flex: 1;
               min-width: 0;
        }

           .defect-header {
               display: flex;
               align-items: center;
               gap: 1rem;
               margin-bottom: 0.75rem;
               flex-wrap: wrap;
        }

           .defect-type {
               font-size: 1.125rem;
               font-weight: 600;
               color: var(--gray-800);
        }

            .defect-confidence {
                background: var(--primary-main);
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.875rem;
                font-weight: 600;
        }

            .defect-details {
                display: flex;
                gap: 1rem;
                font-size: 0.875rem;
                color: var(--gray-600);
                flex-wrap: wrap;
        }

            .detail-item {
                background: var(--gray-100);
                padding: 0.25rem 0.5rem;
                border-radius: 4px;
        }

            /* Live detection snapshot preview */
             .defect-frame-preview {
                 display: flex;
                 flex-direction: column;
                 align-items: center;
                 gap: 0.75rem;
                 flex-shrink: 0;
        }

            .defect-thumbnail {
                 width: 140px;
                 height: 100px;
                 object-fit: cover;
                 border-radius: 8px;
                 cursor: pointer;
                 border: 2px solid var(--gray-200);
                 transition: all 0.3s ease;
                 box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

            .defect-thumbnail:hover {
                 border-color: var(--primary-main);
                 transform: scale(1.05);
                 box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

           .frame-actions {
                display: flex;
                gap: 0.5rem;
        }

          .btn-mini {
               padding: 0.375rem 0.75rem;
               font-size: 0.75rem;
                border: 1px solid var(--gray-300);
               background: white;
                border-radius: 6px;
                 cursor: pointer;
                 transition: all 0.2s;
                font-weight: 500;
        }

           .btn-mini:hover {
                background: var(--primary-main);
                color: white;
                border-color: var(--primary-main);
        }

/* Live detection overlay enhancements */
            #canvas {
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

      /* Enhanced measurement help section */
            .measurement-help {
                background: linear-gradient(135deg, #f0f9ff, #e0e7ff);
                border: 1px solid #bfdbfe;
                border-radius: 12px;
                padding: 1.5rem;
                margin-top: 1.5rem;
        }

          .measurement-help h5 {
               color: var(--primary-main);
               font-size: 1.125rem;
               font-weight: 600;
               margin-bottom: 0.75rem;
        }

          .measurement-help ul {
               list-style: none;
               padding-left: 0;
        }

          .measurement-help li {
               display: flex;
               align-items: flex-start;
              gap: 0.5rem;
              margin-bottom: 0.5rem;
              color: var(--gray-700);
        }

         .measurement-help li::before {
             content: "‚Ä¢";
             color: var(--primary-main);
             font-weight: bold;
             width: 1em;
             flex-shrink: 0;
        }

         /* Status indicators for measurements */
          .measure-status.detected {
              background: var(--success);
              color: white;
        }

          .measure-status.pass {
              background: var(--success);
              color: white;
        }

          .measure-status.fail {
              background: var(--error);
              color: white;
        }

        
          .measure-status.unknown {
               background: var(--warning);
               color: white;
         }



          /* Responsive enhancements */
        @media (max-width: 768px) {
            .defect-item-enhanced {
                  flex-direction: column;
                  text-align: center;
        }
    
            .defect-frame-preview {
                  width: 100%;
                  max-width: 200px;
        }
    
            .measurement-grid {
                 grid-template-columns: 1fr;
        }
    
           .defect-header {
                justify-content: center;
        }
    
           .defect-details {
                justify-content: center;
        }
           #angleGuidanceOverlay {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
                animation: fadeIn 0.3s ease-in;
        }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translate(-50%, -45%);
                }
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%);
                }
            }

            #angleGuidanceOverlay button {
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0%, 100% {
                transform: scale(1);
            }
            50% {
               transform: scale(1.05);
           }
        }
    }

    </style>
</head>
<body>
    
    <!-- Connection Status Indicator -->
    <div id="connectionStatus" class="connection-status disconnected">Backend Disconnected</div>
    
    <!-- Header -->
    <header class="header">
        <nav class="nav">
            <div class="logo-container">
                <img src="logo.jpeg" alt="RICI Industries Logo" class="company-logo">
                
                <div class="company-info">
                    <h2>RICI Industries</h2>
                    <div class="ai-badge">AI Powered Inspection System</div>
                </div>
            </div>
            <div class="nav-status">
                <div class="ai-indicator">AI</div>
                <span class="status-text">Advanced Machine Learning</span>
            </div>
        </nav>
    </header>
    
    <!-- Main Content -->
    <main class="main-content">
        <!-- Hero Section -->
        <section class="hero">
            <h1>AI Powered Smart Inspection System</h1>
            <p>Advanced machine learning-powered inspection for welding defects, coating analysis, and dimensional compliance verification with real-time processing capabilities.</p>
        </section>
        
        <!-- Feature Cards -->
        <div class="feature-cards">
            <!-- Weld Detection Card -->
            <div class="feature-card weld">
                <div class="card-icon weld">üîß</div>
                <h3>Weld Defect Detection</h3>
                <p>Comprehensive analysis of welding quality using state-of-the-art computer vision to identify critical defects.</p>
                <ul class="card-features">
                    <li><span class="checkmark">‚úì</span>Arc Strike Detection</li>
                    <li><span class="checkmark">‚úì</span>Porosity & Crack Analysis</li>
                    <li><span class="checkmark">‚úì</span>Burn Through Identification</li>
                    <li><span class="checkmark">‚úì</span>Spatter & Undercut Detection</li>
                    <li><span class="checkmark">‚úì</span>Slag Inclusion Analysis</li>
                    <li><span class="checkmark">‚úì</span>Real-time Processing</li>
                </ul>
                <button class="btn btn-primary" onclick="openDetectionModal('weld')">Start Weld Analysis</button>
            </div>
            
            <!-- Coating Detection Card -->
            <div class="feature-card coating">
                <div class="card-icon coating">üé®</div>
                <h3>Coating Defect Analysis</h3>
                <p>Intelligent surface coating inspection to ensure quality standards and identify imperfections early.</p>
                <ul class="card-features">
                    <li><span class="checkmark">‚úì</span>Blister & Orange Peel Detection</li>
                    <li><span class="checkmark">‚úì</span>Paint Sagging Analysis</li>
                    <li><span class="checkmark">‚úì</span>Wrinkle & Crack Identification</li>
                    <li><span class="checkmark">‚úì</span>Chalking & Cratering Detection</li>
                    <li><span class="checkmark">‚úì</span>Peel-off & Rash Analysis</li>
                    <li><span class="checkmark">‚úì</span>Multi-format Support</li>
                </ul>
                <button class="btn btn-secondary" onclick="openDetectionModal('coating')">Start Coating Analysis</button>
            </div>
            
            <!-- Flange Analysis Card -->
            <div class="feature-card flange">
                <div class="card-icon flange">üìè</div>
                <h3>Flange Dimension Analysis</h3>
                <p>Precision dimensional measurement and compliance verification using ArUco marker-based scaling.</p>
                <ul class="card-features">
                    <li><span class="checkmark">‚úì</span>Outer & Inner Diameter Measurement</li>
                    <li><span class="checkmark">‚úì</span>Bolt Hole Count & Spacing</li>
                    <li><span class="checkmark">‚úì</span>ArUco Marker Scaling</li>
                    <li><span class="checkmark">‚úì</span>Specification Compliance Check</li>
                    <li><span class="checkmark">‚úì</span>Detailed Measurement Reports</li>
                    <li><span class="checkmark">‚úì</span>CSV Specification Import</li>
                </ul>
                <button class="btn btn-success" onclick="openDetectionModal('flange')">Start Dimension Analysis</button>
            </div>
        </div>
    </main>
    
    <!-- Detection Modal -->
    <div id="detectionModal" class="modal">
        <div class="modal-content">
            <div id="modalHeader" class="modal-header weld">
                <h2 id="modalTitle" class="modal-title">
                    <span id="modalIcon">üîß</span>
                    Advanced Defect Detection System
                </h2>
                <button class="close" onclick="closeModal()">&times;</button>
            </div>
            
            <div class="modal-body">
                <!-- Detection Type Selector -->
                <div class="detection-selector">
                    <button id="weldTypeBtn" class="detection-type-btn weld active" onclick="setDetectionType('weld')">
                        üîß Weld Detection
                    </button>
                    <button id="coatingTypeBtn" class="detection-type-btn coating" onclick="setDetectionType('coating')">
                        üé® Coating Analysis
                    </button>
                    <button id="flangeTypeBtn" class="detection-type-btn flange" onclick="setDetectionType('flange')">
                        üìè Flange Measurement
                    </button>
                </div>
                
                <!-- Upload Area -->
                <div id="uploadArea" class="upload-area weld" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-icon">üìÅ</div>
                    <h3>Upload Files or Use Live Camera</h3>
                    <p>Supported formats: JPG, PNG, MP4, WebM, AVI | Max size: 100MB per file</p>
                </div>
                
                <!-- Hidden File Input -->
                <input type="file" id="fileInput" accept="image/*,video/*" multiple style="display: none;" onchange="handleFileUpload(event)">
                
                <!-- Replace the action buttons section in your HTML with this -->
             <div class="action-buttons">
                 <button class="action-btn primary" onclick="document.getElementById('fileInput').click()">
                      üìÅ Upload Files
                 </button>
                 <button class="action-btn success" onclick="startCamera()">
                      üìπ Live Camera Detection
                  </button>
                  <button class="action-btn secondary" onclick="capturePhoto()">
                      üì∏ Capture Single Photo
                  </button>
                  <button class="action-btn" onclick="stopCamera()">
                     ‚èπÔ∏è Stop Camera
                  </button>
                  <button class="action-btn" onclick="resetDetection()">
                     üîÑ Reset Session
                 </button>
            </div>
                
                <!-- Detection Area -->
                <div class="detection-area">
                    <div id="cameraStatus" class="status-indicator status-ready">
                        <span>‚ö°</span>Ready to Start Analysis
                    </div>
                    <video id="video" autoplay playsinline style="display: none;"></video>
                    <canvas id="canvas" style="display: none;"></canvas>
                    <img id="previewImage" class="preview-image hidden" alt="Analysis Preview">
                    <div id="placeholder" class="placeholder">
                        Upload files or start live camera detection to begin AI analysis
                    </div>
                </div>
                
                <!-- Results Panel -->
                <div class="results-panel">
                    <div class="results-header">
                        <div class="results-icon">ü§ñ</div>
                        <h3 id="resultsTitle">Detection Results</h3>
                    </div>
                    
                    <div class="defect-list" id="defectList">
                        <div class="empty-state">
                            No defects detected yet. Start an analysis to see results here.
                        </div>
                    </div>
                    
                    <div class="export-buttons">
                        <button class="export-btn" onclick="exportCSV()">
                            üìä Export CSV
                        </button>
                        <button class="export-btn" onclick="exportExcel()">
                            üìã Export Excel
                        </button>
                        <button class="export-btn" onclick="exportPDF()">
                            üìÑ Generate Report
                        </button>
                    </div>
                </div>
                
                <!-- AI Insights Panel -->
                <div class="ai-insights">
                    <div class="insights-header">
                        <div class="insights-icon">üß†</div>
                        <h4>AI Insights & Recommendations</h4>
                    </div>
                    <div class="insights-content" id="insightsContent">
                        AI analysis and recommendations will appear here after detection. The system will provide specific guidance based on detected defects and their severity levels.
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // AI Defect Detection System - JavaScript Implementation

// Global Variables
let currentDetectionType = 'weld';
let isLiveDetectionActive = false;
let videoStream = null;
let video = null;
let canvas = null;
let ctx = null;
let detectionInterval = null;
let sessionResults = [];
let backendConnected = false;
let isRecording = false;
let flangeStandards = [];
let selectedStandard = null;
let liveRecordingActive = false;
let recordingStartTime = null;
let angleCheckInterval = null;
let angleGuidanceOverlay = null;
let currentUser = null;
let authToken = null;

let preferredUnit = 'inches'; // Global unit preference

// API Configuration
//const API_BASE_URL = 'http://localhost:5000/api';
const API_BASE_URL = 'https://blushfully-unreiterative-velia.ngrok-free.dev/api';

const DETECTION_INTERVAL = 1000; // 1 second between live detections

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    initializeElements();
    checkBackendConnection();
    loadFlangeStandards();
    
    // Check backend connection every 30 seconds
    setInterval(checkBackendConnection, 30000);
});

// Initialize DOM elements
function initializeElements() {
    video = document.getElementById('video');
    canvas = document.getElementById('canvas');
    if (canvas) {
        ctx = canvas.getContext('2d');
    }
    
    // Add event listeners
    window.addEventListener('click', function(event) {
        if (event.target === document.getElementById('detectionModal')) {
            closeModal();
        }
    });
    
    // Prevent modal close when clicking inside modal content
    document.querySelector('.modal-content').addEventListener('click', function(event) {
        event.stopPropagation();
    });
}

// Check backend connection status
async function checkBackendConnection() {
    try {
        const response = await fetch(`${API_BASE_URL}/health`);
        const data = await response.json();
        
        if (data.status === 'healthy') {
            updateConnectionStatus(true);
            backendConnected = true;
        } else {
            updateConnectionStatus(false);
            backendConnected = false;
        }
    } catch (error) {
        console.error('Backend connection check failed:', error);
        updateConnectionStatus(false);
        backendConnected = false;
    }
}

// Update connection status indicator
function updateConnectionStatus(connected) {
    const statusElement = document.getElementById('connectionStatus');
    if (connected) {
        statusElement.className = 'connection-status connected';
        statusElement.textContent = 'Backend Connected';
    } else {
        statusElement.className = 'connection-status disconnected';
        statusElement.textContent = 'Backend Disconnected';
    }
}


function initializeAngleGuidance() {
    // Create angle guidance overlay
    if (!angleGuidanceOverlay) {
        angleGuidanceOverlay = document.createElement('div');
        angleGuidanceOverlay.id = 'angleGuidanceOverlay';
        angleGuidanceOverlay.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            z-index: 15;
            min-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
            border: 3px solid;
        `;
        document.querySelector('.detection-area').appendChild(angleGuidanceOverlay);
    }
}


async function startAngleGuidance() {
    if (currentDetectionType !== 'flange') return;
    
    initializeAngleGuidance();
    angleGuidanceOverlay.style.display = 'block';
    
    // Check angle every 500ms
    angleCheckInterval = setInterval(async () => {
        if (!video || !video.videoWidth) return;
        
        try {
            // Capture current frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0);
            
            const frameDataURL = tempCanvas.toDataURL('image/jpeg', 0.7);
            
            // Check angle
            const response = await fetch(`${API_BASE_URL}/check_camera_angle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image: frameDataURL })
            });
            
            const result = await response.json();
            
            if (result.success && result.angle_info) {
                updateAngleGuidanceDisplay(result.angle_info, result.message);
            } else {
                updateAngleGuidanceDisplay(null, result.message || 'Place ArUco marker in view');
            }
            
        } catch (error) {
            console.error('Angle check error:', error);
        }
    }, 500);
}



///// new function i am adding 
// ‚úÖ NEW FUNCTION: Real-time angle checking during capture
function startCaptureAngleGuidance() {
    if (currentDetectionType !== 'flange') {
        // Enable button immediately for non-flange detection
        document.getElementById('takePictureBtn').disabled = false;
        document.getElementById('takePictureBtn').textContent = 'üì∏ Take Picture';
        return;
    }
    
    const angleCheckInterval = setInterval(async () => {
        const captureVideo = document.getElementById('captureVideo');
        const statusDiv = document.getElementById('angleGuidanceStatus');
        const takeBtn = document.getElementById('takePictureBtn');
        
        if (!captureVideo || !captureVideo.videoWidth) return;
        
        try {
            // Capture current frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = captureVideo.videoWidth;
            tempCanvas.height = captureVideo.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(captureVideo, 0, 0);
            
            const frameDataURL = tempCanvas.toDataURL('image/jpeg', 0.7);
            
            // Check angle
            const response = await fetch(`${API_BASE_URL}/check_camera_angle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image: frameDataURL })
            });
            
            const result = await response.json();
            
            if (result.success && result.angle_info) {
                updateCaptureAngleDisplay(result.angle_info, result.message, statusDiv, takeBtn);
            } else {
                // No marker found
                statusDiv.className = 'angle-status waiting';
                statusDiv.innerHTML = `
                    <div class="angle-icon">üîç</div>
                    <div class="angle-text">${result.message || 'Place 4.8cm ArUco marker in view'}</div>
                `;
                takeBtn.disabled = true;
                takeBtn.textContent = 'üì∏ Take Picture (Marker required)';
            }
            
        } catch (error) {
            console.error('Angle check error:', error);
        }
    }, 500);
    
    // Store interval ID for cleanup
    window.currentAngleCheckInterval = angleCheckInterval;
}




// ‚úÖ NEW FUNCTION: Update angle display during capture
function updateCaptureAngleDisplay(angleInfo, message, statusDiv, takeBtn) {
    const status = angleInfo.status;
    const tilt = angleInfo.total_tilt;
    
    let icon, className, buttonText, detailsHTML;
    
    if (status === 'perfect') {
        icon = '‚úÖ';
        className = 'angle-status perfect';
        buttonText = 'üì∏ TAKE PICTURE NOW (Perfect Angle!)';
        takeBtn.disabled = false;
        detailsHTML = `Tilt: ${tilt.toFixed(1)}¬∞ (Perfect!)`;
    } else if (status === 'good') {
        icon = '‚úÖ';
        className = 'angle-status good';
        buttonText = 'üì∏ Take Picture (Good angle)';
        takeBtn.disabled = false;
        detailsHTML = `Tilt: ${tilt.toFixed(1)}¬∞ (Within tolerance)`;
    } else {
        icon = '‚ö†Ô∏è';
        className = 'angle-status adjust';
        buttonText = 'üì∏ Take Picture (Adjust angle first)';
        takeBtn.disabled = false; // Allow capture but warn
        detailsHTML = `Tilt: ${tilt.toFixed(1)}¬∞ (Target: <15¬∞)`;
    }
    
    statusDiv.className = className;
    statusDiv.innerHTML = `
        <div class="angle-icon">${icon}</div>
        <div>
            <div class="angle-text">${message}</div>
            <div class="angle-details">${detailsHTML}</div>
        </div>
    `;
    
    takeBtn.textContent = buttonText;
}





function updateAngleGuidanceDisplay(angleInfo, message) {
    if (!angleGuidanceOverlay) return;
    
    let borderColor = '#f59e0b'; // Default: warning yellow
    let icon = '‚ö†Ô∏è';
    let statusText = 'ADJUST ANGLE';
    
    if (angleInfo) {
        if (angleInfo.status === 'perfect') {
            borderColor = '#10b981'; // Green
            icon = '‚úÖ';
            statusText = 'PERFECT ANGLE';
        } else if (angleInfo.status === 'good') {
            borderColor = '#22c55e'; // Light green
            icon = '‚úÖ';
            statusText = 'GOOD ANGLE';
        } else {
            borderColor = '#ef4444'; // Red
            icon = '‚ùå';
            statusText = 'ADJUST CAMERA';
        }
        
        angleGuidanceOverlay.innerHTML = `
            <div style="font-size: 3rem; margin-bottom: 1rem;">${icon}</div>
            <div style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">${statusText}</div>
            <div style="font-size: 1rem; line-height: 1.6; margin-bottom: 1rem;">${message}</div>
            <div style="font-size: 0.875rem; opacity: 0.8;">
                Tilt: ${angleInfo.total_tilt.toFixed(1)}¬∞ 
                ${angleInfo.status === 'perfect' || angleInfo.status === 'good' ? '(Target: <15¬∞)' : ''}
            </div>
            ${angleInfo.status === 'perfect' ? `
                <button onclick="capturePhoto()" class="btn btn-primary" style="margin-top: 1rem;">
                    üì∏ TAKE SHOT NOW
                </button>
            ` : ''}
        `;
    } else {
        angleGuidanceOverlay.innerHTML = `
            <div style="font-size: 3rem; margin-bottom: 1rem;">üéØ</div>
            <div style="font-size: 1.25rem; font-weight: bold; margin-bottom: 1rem;">SEARCHING FOR MARKER</div>
            <div style="font-size: 1rem; line-height: 1.6;">${message}</div>
        `;
        borderColor = '#6b7280'; // Gray
    }
    
    angleGuidanceOverlay.style.borderColor = borderColor;
}

function stopAngleGuidance() {
    if (angleCheckInterval) {
        clearInterval(angleCheckInterval);
        angleCheckInterval = null;
    }
    
    if (angleGuidanceOverlay) {
        angleGuidanceOverlay.style.display = 'none';
    }
}






// Load available flange standards
async function loadFlangeStandards() {
    try {
        const response = await fetch(`${API_BASE_URL}/model_info`);
        const data = await response.json();
        
        if (data.success && data.flange_specifications_loaded) {
            // Extract unique standards from the backend info
            flangeStandards = ['ASME B16.5', 'DIN 2573', 'JIS B2220', 'BS 4504'];
            console.log('Flange standards loaded:', flangeStandards);
        }
    } catch (error) {
        console.error('Failed to load flange standards:', error);
        flangeStandards = ['ASME B16.5', 'DIN 2573']; // Fallback standards
    }
}

// Modal Management Functions
function openDetectionModal(type) {
    if (!backendConnected) {
        showNotification('Backend is not connected. Please check your connection.', 'error');
        return;
    }
    
    setDetectionType(type);
    document.getElementById('detectionModal').style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Special handling for flange detection
    if (type === 'flange') {
        showStandardSelector();
    }
}

function closeModal() {
    document.getElementById('detectionModal').style.display = 'none';
    document.body.style.overflow = 'auto';
    
    // Clean up resources
    if (isLiveDetectionActive) {
        stopCamera();
    }
    
    // Hide standard selector if visible
    hideStandardSelector();
}

// Show standard selector for flange detection
function showStandardSelector() {
    // Create standard selector if it doesn't exist
    let standardSelector = document.getElementById('standardSelector');
    if (!standardSelector) {
        standardSelector = document.createElement('div');
        standardSelector.id = 'standardSelector';
        standardSelector.className = 'standard-selector';
        standardSelector.innerHTML = `
            <div class="standard-selector-content">
                <h3>Choose Flange Standard</h3>
                <p>Select the standard specification for dimensional compliance verification:</p>
                <div class="standard-options">
                    ${flangeStandards.map(standard => `
                        <button class="standard-btn" onclick="selectStandard('${standard}')">
                            <div class="standard-icon">üìê</div>
                            <div class="standard-name">${standard}</div>
                            <div class="standard-desc">${getStandardDescription(standard)}</div>
                        </button>
                    `).join('')}
                </div>
                <button class="btn btn-secondary" onclick="hideStandardSelector()">Cancel</button>
            </div>
        `;
        
        // Add styles for standard selector
        const style = document.createElement('style');
        style.textContent = `
            .standard-selector {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1002;
                backdrop-filter: blur(8px);
            }
            .standard-selector-content {
                background: white;
                border-radius: var(--radius-2xl);
                padding: 2rem;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: var(--shadow-2xl);
            }
            .standard-selector h3 {
                color: var(--gray-800);
                font-size: 1.5rem;
                font-weight: 700;
                margin-bottom: 1rem;
                text-align: center;
            }
            .standard-selector p {
                color: var(--gray-600);
                margin-bottom: 2rem;
                text-align: center;
            }
            .standard-options {
                display: grid;
                gap: 1rem;
                margin-bottom: 2rem;
            }
            .standard-btn {
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 1.5rem;
                border: 2px solid var(--gray-200);
                background: white;
                border-radius: var(--radius-lg);
                cursor: pointer;
                transition: var(--transition-normal);
                text-align: left;
            }
            .standard-btn:hover {
                border-color: var(--secondary-emerald);
                background: var(--gray-50);
                transform: translateY(-2px);
                box-shadow: var(--shadow-md);
            }
            .standard-icon {
                font-size: 2rem;
                flex-shrink: 0;
            }
            .standard-name {
                font-weight: 600;
                color: var(--gray-800);
                font-size: 1.125rem;
            }
            .standard-desc {
                color: var(--gray-600);
                font-size: 0.875rem;
                margin-top: 0.25rem;
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(standardSelector);
    }
    
    standardSelector.style.display = 'flex';
}

function hideStandardSelector() {
    const standardSelector = document.getElementById('standardSelector');
    if (standardSelector) {
        standardSelector.style.display = 'none';
    }
}

function selectStandard(standard) {
    selectedStandard = standard;
    hideStandardSelector();
    showNotification(`Selected standard: ${standard}`, 'success');
    
    // Update the UI to show selected standard
    updateFlangeUI(standard);
}

function getStandardDescription(standard) {
    const descriptions = {
        'ASME B16.5': 'American standard for pipe flanges and flanged fittings',
        'DIN 2573': 'German standard for steel flanges',
        'JIS B2220': 'Japanese standard for steel pipe flanges',
        'BS 4504': 'British standard for flanges and their joints'
    };
    return descriptions[standard] || 'Industrial flange standard';
}

function updateFlangeUI(standard) {
    const uploadArea = document.getElementById('uploadArea');
    const existingStandardInfo = uploadArea.querySelector('.standard-info');
    
    if (existingStandardInfo) {
        existingStandardInfo.remove();
    }
    
    const standardInfo = document.createElement('div');
    standardInfo.className = 'standard-info';
    standardInfo.innerHTML = `
        <div style="margin-top: 1rem; padding: 1rem; background: var(--success); color: white; border-radius: var(--radius-md); font-size: 0.875rem;">
            <strong>Selected Standard: ${standard}</strong><br>
            ${getStandardDescription(standard)}
        </div>
    `;
    uploadArea.appendChild(standardInfo);
}

// FIXED: Detection Type Management with unit selector for flange
function setDetectionType(type) {
    currentDetectionType = type;
    
    // Update active button states
    document.querySelectorAll('.detection-type-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById(`${type}TypeBtn`).classList.add('active');
    
    // Update modal styling
    const modalHeader = document.getElementById('modalHeader');
    const uploadArea = document.getElementById('uploadArea');
    modalHeader.className = `modal-header ${type}`;
    uploadArea.className = `upload-area ${type}`;
    
    // Update modal content
    const icons = { weld: 'üîß', coating: 'üé®', flange: 'üìè' };
    const titles = { 
        weld: 'Weld Defect Detection', 
        coating: 'Coating Analysis', 
        flange: 'Flange Dimension Analysis' 
    };
    
    document.getElementById('modalIcon').textContent = icons[type];
    document.getElementById('modalTitle').innerHTML = `
        <span id="modalIcon">${icons[type]}</span>
        ${titles[type]}
    `;
    
    // Update results title
    document.getElementById('resultsTitle').textContent = `${titles[type]} Results`;
    
    // Clear previous results
    clearResults();
    
    // Reset file input
    document.getElementById('fileInput').value = '';
    
    // FIXED: Show unit selector for flange detection
    if (type === 'flange') {
        showUnitSelector();
    } else {
        hideUnitSelector();
    }
}


// File Upload Handling
function handleFileUpload(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    
    // Special handling for flange detection - ensure standard is selected
    if (currentDetectionType === 'flange' && !selectedStandard) {
        showStandardSelector();
        return;
    }
    
    if (files.length === 1) {
        processSingleFile(files[0]);
    } else {
        processMultipleFiles(files);
    }
}


async function processSingleFile(file) {
    if (!validateFile(file)) return;

    const isVideo = file.type.startsWith('video/');
    
    try {
        // Resize image if it's too large (non-video files only)
        let fileToProcess = file;
        if (!isVideo && file.size > 10 * 1024 * 1024) { // 10MB threshold
            showProcessingStatus('Optimizing large image...');
            fileToProcess = await resizeImageIfNeeded(file);
        }
        
        if (currentDetectionType === 'flange' && !isVideo) {
            // FIXED: Check if unit is selected first
            if (!preferredUnit) {
                showUnitSelector();
                showNotification('Please select your preferred measurement unit first', 'warning');
                return;
            }
            
            // Use enhanced flange detection with units
            await detectFlangeWithUnits(fileToProcess);
            return;
        }
        
        // Regular processing for other types (weld/coating)
        showProcessingStatus(`Analyzing ${isVideo ? 'video' : 'image'}... ${isVideo ? 'This may take a few minutes.' : ''}`);
        
        const formData = new FormData();
        if (isVideo) {
            formData.append('video', fileToProcess);
        } else {
            formData.append('image', fileToProcess);
        }
        formData.append('detection_type', currentDetectionType);
        
        const endpoint = '/detect_image';
        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server error ${response.status}: ${errorText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            displayResults(result);
            
            if (isVideo && result.video_info) {
                const uniqueDefects = result.defects ? aggregateVideoDefects(result.defects).length : 0;
                showSuccessStatus(`Video analysis complete: ${uniqueDefects} unique defect types found`);
            } else {
                showSuccessStatus(`Analysis complete (${result.image_size || 'unknown size'})`);
            }
        } else {
            showErrorStatus(result.error || 'Analysis failed');
        }
        
    } catch (error) {
        console.error('File processing error:', error);
        if (error.message.includes('413') || error.message.includes('too large')) {
            showErrorStatus('Image too large. Please use a smaller image (max 50MB).');
        } else if (error.message.includes('400')) {
            showErrorStatus('Invalid image format. Please use JPG or PNG files.');
        } else {
            showErrorStatus(`Processing failed: ${error.message}`);
        }
    }
}


function showPreviewImage(base64Image) {
    const previewImg = document.getElementById('previewImage');
    previewImg.src = base64Image;             // set annotated image
    previewImg.classList.remove('hidden');    // make visible

    // Hide other elements
    document.getElementById('placeholder').style.display = 'none';
    document.getElementById('video').style.display = 'none';
    document.getElementById('canvas').style.display = 'none';
}

async function processMultipleFiles(files) {
    // Special handling for flange detection - ensure standard is selected
    if (currentDetectionType === 'flange' && !selectedStandard) {
        showStandardSelector();
        return;
    }
    
    const validFiles = Array.from(files).filter(validateFile);
    if (validFiles.length === 0) return;
    
    try {
        showProcessingStatus(`Analyzing ${validFiles.length} files...`);
        
        const formData = new FormData();
        validFiles.forEach(file => {
            formData.append('images', file);
        });
        formData.append('detection_type', currentDetectionType);
        
        const response = await fetch(`${API_BASE_URL}/detect_images`, {
            method: 'POST',
            body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
            displayMultipleResults(result);
            showSuccessStatus(`Analyzed ${result.total_images} files`);
        } else {
            showErrorStatus(result.error || 'Analysis failed');
        }
        
    } catch (error) {
        console.error('Multiple file processing error:', error);
        showErrorStatus('Processing failed. Please try again.');
    }
}

function validateFile(file) {
    const maxSize = 50 * 1024 * 1024; // 100MB
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'video/mp4', 'video/webm', 'video/avi'];
    
    if (file.size > maxSize) {
        showNotification(`File ${file.name} is too large. Max size: 50MB`, 'error');
        return false;
    }
    
    if (!allowedTypes.includes(file.type)) {
        showNotification(`File ${file.name} type not supported`, 'error');
        return false;
    }
    
    return true;
}

// Add this new function to resize images before sending
async function resizeImageIfNeeded(file) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
            // Max dimensions
            const maxWidth = 1920;
            const maxHeight = 1080;
            
            let { width, height } = img;
            
            // Calculate new dimensions if image is too large
            if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Draw and compress
            ctx.drawImage(img, 0, 0, width, height);
            
            canvas.toBlob((blob) => {
                const resizedFile = new File([blob], file.name, {
                    type: 'image/jpeg',
                    lastModified: Date.now()
                });
                resolve(resizedFile);
            }, 'image/jpeg', 0.8); // 80% quality
        };
        
        img.src = URL.createObjectURL(file);
    });
}



// Replace the existing startCamera function with this:
async function startCamera() {
    if (currentDetectionType === 'flange' && !selectedStandard) {
        showStandardSelector();
        return;
    }
    
    try {
        if (videoStream) {
            stopCamera();
        }
        
        videoStream = await navigator.mediaDevices.getUserMedia({
            video: { 
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                facingMode: 'environment'
            }
        });
        
        video.srcObject = videoStream;
        video.style.display = 'block';
        document.getElementById('placeholder').style.display = 'none';
        
        canvas.width = 1280;
        canvas.height = 720;
        
        isLiveDetectionActive = true;
        liveRecordingActive = true;
        recordingStartTime = new Date();
        
        showActiveStatus('üî¥ LIVE: Recording & analyzing...');
        
        // NEW: Start angle guidance for flange detection
        if (currentDetectionType === 'flange') {
            startAngleGuidance();
        } else {
            startLiveDetection();
        }
        
    } catch (error) {
        console.error('Camera access error:', error);
        if (error.name === 'NotAllowedError') {
            showErrorStatus('üö´ Camera access blocked. Please allow it in browser settings.');
        } else if (error.name === 'NotFoundError') {
            showErrorStatus('üì∑ No camera detected. Check your webcam.');
        } else {
            showErrorStatus(`‚ö†Ô∏è Camera error: ${error.message}`);
        }
    }
}



async function stopCamera() {

    stopAngleGuidance();


    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
    }
    
    if (video) {
        video.style.display = 'none';
    }
    
    if (detectionInterval) {
        clearInterval(detectionInterval);
        detectionInterval = null;
    }
    
    isLiveDetectionActive = false;
    
    // Stop live recording and get download link
    if (liveRecordingActive) {
        try {
            const response = await fetch(`${API_BASE_URL}/stop_live_recording`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            
            if (result.success) {
                liveRecordingActive = false;
                showSuccessStatus('Recording saved successfully!');
                
                // Show download option
                showLiveRecordingDownload(result.download_url, result.stream_url, result.filename);
                
                const duration = recordingStartTime ? 
                    ((new Date() - recordingStartTime) / 1000).toFixed(1) : 0;
                
                showNotification(`Live recording saved! Duration: ${duration}s`, 'success');
            } else {
                showErrorStatus(result.error || 'Failed to save recording');
            }
        } catch (error) {
            console.error('Error stopping recording:', error);
            showErrorStatus('Failed to save recording');
        }
    }

    // ‚úÖ Hide capture button when camera stops
    document.getElementById('captureBtn').style.display = 'none';
    
    document.getElementById('placeholder').style.display = 'block';
    showReadyStatus();
}


async function capturePhoto() {
    try {
        // Request camera access for single photo capture
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                facingMode: 'environment'
            }
        });
        
        // Create capture modal with angle guidance
        const captureModal = document.createElement('div');
        captureModal.className = 'capture-modal';
        captureModal.innerHTML = `
            <div class="capture-overlay">
                <div class="capture-container">
                    <div class="capture-header">
                        <h3>üì∏ Capture Photo with Angle Guidance</h3>
                        <button onclick="closeCaptureModal()" class="close-capture">‚úï</button>
                    </div>
                    
                    <!-- ‚úÖ ANGLE GUIDANCE OVERLAY -->
                    <div class="angle-guidance-container">
                        <div id="angleGuidanceStatus" class="angle-status waiting">
                            <div class="angle-icon">üéØ</div>
                            <div class="angle-text">Searching for ArUco marker...</div>
                            <div class="angle-details"></div>
                        </div>
                    </div>
                    
                    <div class="capture-preview">
                        <video id="captureVideo" autoplay playsinline></video>
                        <canvas id="captureCanvas" style="display: none;"></canvas>
                    </div>
                    
                    <div class="capture-actions">
                        <button id="takePictureBtn" onclick="takePicture()" class="btn btn-primary" disabled>
                            üì∏ Take Picture (Waiting for good angle...)
                        </button>
                        <button onclick="closeCaptureModal()" class="btn btn-secondary">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add enhanced capture modal styles
        if (!document.getElementById('captureModalStyles')) {
            const style = document.createElement('style');
            style.id = 'captureModalStyles';
            style.textContent = `
                .capture-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 1004;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: rgba(0,0,0,0.9);
                }
                .capture-container {
                    background: white;
                    border-radius: 16px;
                    max-width: 90vw;
                    max-height: 90vh;
                    overflow: hidden;
                    box-shadow: 0 25px 50px rgba(0,0,0,0.3);
                }
                .capture-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 1rem 1.5rem;
                    border-bottom: 1px solid #e5e7eb;
                    background: linear-gradient(135deg, #2563eb, #1e40af);
                    color: white;
                }
                .capture-header h3 {
                    margin: 0;
                    font-size: 1.25rem;
                }
                .close-capture {
                    background: rgba(255,255,255,0.2);
                    border: none;
                    font-size: 1.5rem;
                    cursor: pointer;
                    padding: 0.5rem;
                    border-radius: 50%;
                    color: white;
                    width: 2.5rem;
                    height: 2.5rem;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s;
                }
                .close-capture:hover {
                    background: rgba(255,255,255,0.3);
                    transform: rotate(90deg);
                }
                
                /* ‚úÖ ANGLE GUIDANCE STYLES */
                .angle-guidance-container {
                    padding: 1rem;
                    background: linear-gradient(135deg, #f0f9ff, #e0e7ff);
                    border-bottom: 2px solid #93c5fd;
                }
                .angle-status {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 1rem;
                    border-radius: 12px;
                    transition: all 0.3s ease;
                }
                .angle-status.waiting {
                    background: #f3f4f6;
                    border: 2px solid #9ca3af;
                }
                .angle-status.adjust {
                    background: #fef3c7;
                    border: 2px solid #f59e0b;
                }
                .angle-status.good {
                    background: #d1fae5;
                    border: 2px solid #10b981;
                }
                .angle-status.perfect {
                    background: #d1fae5;
                    border: 2px solid #059669;
                    animation: pulse-success 2s infinite;
                }
                @keyframes pulse-success {
                    0%, 100% { box-shadow: 0 0 0 0 rgba(5, 150, 105, 0.4); }
                    50% { box-shadow: 0 0 0 10px rgba(5, 150, 105, 0); }
                }
                .angle-icon {
                    font-size: 2.5rem;
                    flex-shrink: 0;
                }
                .angle-text {
                    flex: 1;
                    font-size: 1.125rem;
                    font-weight: 600;
                    color: #374151;
                }
                .angle-details {
                    font-size: 0.875rem;
                    color: #6b7280;
                    margin-top: 0.25rem;
                }
                
                .capture-preview {
                    padding: 1rem;
                    text-align: center;
                    background: #f8fafc;
                }
                #captureVideo {
                    max-width: 100%;
                    max-height: 400px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                }
                .capture-actions {
                    display: flex;
                    gap: 1rem;
                    padding: 1rem;
                    justify-content: center;
                    border-top: 1px solid #e5e7eb;
                }
                #takePictureBtn:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(captureModal);
        
        // Set up video stream
        const captureVideo = document.getElementById('captureVideo');
        captureVideo.srcObject = stream;
        
        // Store stream reference for cleanup
        window.currentCaptureStream = stream;
        
        // ‚úÖ START ANGLE CHECKING
        startCaptureAngleGuidance();
        
    } catch (error) {
        console.error('Capture photo error:', error);
        showNotification('Camera access denied or not available', 'error');
    }
}


// ‚úÖ UPDATED: Clean up angle checking when modal closes
function closeCaptureModal() {
    const modal = document.querySelector('.capture-modal');
    if (modal) {
        // Stop camera stream
        if (window.currentCaptureStream) {
            window.currentCaptureStream.getTracks().forEach(track => track.stop());
            window.currentCaptureStream = null;
        }
        
        // Clear angle checking interval
        if (window.currentAngleCheckInterval) {
            clearInterval(window.currentAngleCheckInterval);
            window.currentAngleCheckInterval = null;
        }
        
        document.body.removeChild(modal);
    }
}


async function takePicture() {
    try {
        const captureVideo = document.getElementById('captureVideo');
        const captureCanvas = document.getElementById('captureCanvas');
        const ctx = captureCanvas.getContext('2d');
        
        // Set canvas size to match video
        captureCanvas.width = captureVideo.videoWidth;
        captureCanvas.height = captureVideo.videoHeight;
        
        // Draw current frame to canvas
        ctx.drawImage(captureVideo, 0, 0);
        
        // Convert to blob
        captureCanvas.toBlob(async (blob) => {
            if (blob) {
                // Create file from blob
                const file = new File([blob], `captured_${Date.now()}.jpg`, { type: 'image/jpeg' });
                
                // Close modal first
                closeCaptureModal();
                
                // Process the captured image
                showNotification('Photo captured! Processing...', 'success');
                await processSingleFile(file);
            }
        }, 'image/jpeg', 0.9);
        
    } catch (error) {
        console.error('Take picture error:', error);
        showNotification('Failed to capture photo', 'error');
    }
}

function closeCaptureModal() {
    const modal = document.querySelector('.capture-modal');
    if (modal) {
        // Stop camera stream
        if (window.currentCaptureStream) {
            window.currentCaptureStream.getTracks().forEach(track => track.stop());
            window.currentCaptureStream = null;
        }
        document.body.removeChild(modal);
    }
}


//new fuction i add 
function showLiveRecordingDownload(downloadUrl, streamUrl, filename) {
    const detectionArea = document.querySelector('.detection-area');
    
    // Remove existing download container
    const existing = detectionArea.querySelector('.live-recording-download');
    if (existing) existing.remove();
    
    const downloadContainer = document.createElement('div');
    downloadContainer.className = 'live-recording-download';
    downloadContainer.innerHTML = `
        <div class="recording-results">
            <h4>üìπ Live Recording Completed</h4>
            <div class="recording-info">
                <p>Your live detection session has been saved with all analyzed frames.</p>
                <div class="recording-actions">
                    <button onclick="window.open('${streamUrl}', '_blank')" class="btn btn-primary">
                        ‚ñ∂Ô∏è Play Recording
                    </button>
                    <button onclick="window.open('${downloadUrl}', '_blank')" class="btn btn-success">
                        üíæ Download Video
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Add styles
    if (!document.getElementById('liveRecordingStyles')) {
        const style = document.createElement('style');
        style.id = 'liveRecordingStyles';
        style.textContent = `
            .live-recording-download {
                margin-top: 1rem;
                padding: 1.5rem;
                background: linear-gradient(135deg, #10b981, #34d399);
                border-radius: 12px;
                color: white;
            }
            .recording-results h4 {
                margin: 0 0 1rem 0;
                font-size: 1.25rem;
            }
            .recording-info p {
                margin-bottom: 1rem;
                opacity: 0.9;
            }
            .recording-actions {
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
            }
            .recording-actions .btn {
                flex: 1;
                min-width: 150px;
            }
        `;
        document.head.appendChild(style);
    }
    
    detectionArea.appendChild(downloadContainer);
}
//this above is new 


// üöÄ Improved Live Detection with robust error handling & overlay alignment
function startLiveDetection() {
    if (!isLiveDetectionActive) return;

    clearLiveResults();
    showActiveStatus('Live detection active - analyzing frames...');

    detectionInterval = setInterval(async () => {
        // Skip if video not ready
        if (!isLiveDetectionActive || !video.videoWidth || !video.videoHeight) return;

        try {
            // üîπ Ensure canvas always matches video size
            if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }

            // üîπ Clear canvas and draw current video frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // üîπ Convert frame to base64 JPEG
            const frameDataURL = canvas.toDataURL('image/jpeg', 0.8);

            // üîπ Prepare detection payload
            const detectionData = {
                image: frameDataURL,
                detection_type: currentDetectionType,
                start_recording: Boolean(
                    liveRecordingActive &&
                    recordingStartTime &&
                    (Date.now() - recordingStartTime) < 1000
                )
            };

            // üîπ Add unit preference for flange detection
            if (currentDetectionType === 'flange') {
                detectionData.unit = preferredUnit || 'inches';
            }

            // üîπ Call backend API
            const response = await fetch(`${API_BASE_URL}/detect_frame`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(detectionData)
            });

            if (!response.ok) throw new Error(`Server error: ${response.status}`);
            const result = await response.json();

            // üîπ Handle results
            if (result.success) {
                // Align overlay with video
                Object.assign(canvas.style, {
                    position: 'absolute',
                    top: `${video.offsetTop}px`,
                    left: `${video.offsetLeft}px`,
                    zIndex: '5',
                    pointerEvents: 'none'
                });

                if (result.detections?.length > 0) {
                    drawDetectionOverlay(result.detections);
                    updateLiveDefectResults(result);

                    showActiveStatus(`üî¥ LIVE: ${result.detections.length} defect(s) detected`);
                } else {
                    // Clear overlay while keeping video frame visible
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    showActiveStatus('üü¢ LIVE: Monitoring...');
                }

                // Process new defects if found
                if (Array.isArray(result.new_defects) && result.new_defects.length > 0) {
                    processNewLiveDefects(result.new_defects);
                }
            } else {
                showErrorStatus(result.error || 'Detection failed');
            }

        } catch (error) {
            console.error('Live detection error:', error);
            showErrorStatus('Live detection interrupted');
        }
    }, DETECTION_INTERVAL);
}


// Process new live defects
function processNewLiveDefects(newDefects) {
    newDefects.forEach(defect => {
        // Add to session results
        sessionResults.push({
            ...defect,
            timestamp: new Date().toISOString(),
            detection_type: currentDetectionType
        });
        
        // Show notification for new defect
        showNotification(`${defect.type} detected (${(defect.confidence * 100).toFixed(1)}%)`, 'warning');
    });
    
    // Limit stored results
    if (sessionResults.length > 1000) {
        sessionResults = sessionResults.slice(-800);
    }
}

// FIXED: Live Detection with proper bounding boxes and snapshots
function drawDetectionOverlay(detections) {
    if (!canvas || !ctx || !video.videoWidth) return;
    
    // Ensure canvas matches video size
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // DON'T redraw video frame - just clear and draw on transparent canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Position canvas exactly over video (responsive fix)
    const videoRect = video.getBoundingClientRect();
    const containerRect = video.parentElement.getBoundingClientRect();
    
    canvas.style.position = 'absolute';
    canvas.style.left = (videoRect.left - containerRect.left) + 'px';
    canvas.style.top = (videoRect.top - containerRect.top) + 'px';
    canvas.style.width = video.offsetWidth + 'px';
    canvas.style.height = video.offsetHeight + 'px';
    canvas.style.zIndex = '10';
    canvas.style.pointerEvents = 'none';
    canvas.style.display = 'block';

    // Draw detections on overlay
    detections.forEach(detection => {
        const [x1, y1, x2, y2] = detection.bbox;
        const width = x2 - x1;
        const height = y2 - y1;

        // Color based on detection type
        let color = '#00ff00';
        if (currentDetectionType === 'weld') {
            color = '#2563eb';
        } else if (currentDetectionType === 'coating') {
            color = '#ea580c';
        } else if (currentDetectionType === 'flange') {
            color = detection.compliance?.status === 'pass' ? '#10b981' : 
                   detection.compliance?.status === 'fail' ? '#ef4444' : '#f59e0b';
        }

        // Draw bounding box
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.strokeRect(x1, y1, width, height);
        
        // Semi-transparent fill
        ctx.fillStyle = color + '20';
        ctx.fillRect(x1, y1, width, height);

        // Label with confidence
        let label = `${detection.type} ${(detection.confidence * 100).toFixed(1)}%`;
        
        // Add flange measurements if available
        if (currentDetectionType === 'flange' && detection.measurements) {
            const unit_symbol = preferredUnit === 'inches' ? '"' : 'mm';
            const od = detection.measurements.outer_dia || detection.measurements.od;
            if (od) {
                label += ` (OD: ${od.toFixed(2)}${unit_symbol})`;
            }
        }

        ctx.font = 'bold 16px Arial';
        const textMetrics = ctx.measureText(label);
        const textWidth = textMetrics.width + 12;
        const textHeight = 24;

        // Background for text
        ctx.fillStyle = color;
        ctx.fillRect(x1, y1 - textHeight - 4, textWidth, textHeight);

        // Text
        ctx.fillStyle = 'white';
        ctx.fillText(label, x1 + 6, y1 - 8);
    });
}

// FIXED: Capture snapshot when defects are found
function captureDefectSnapshot() {
    if (!video || !canvas || !ctx) return null;
    
    // Create temporary canvas for snapshot
    const snapshotCanvas = document.createElement('canvas');
    const snapshotCtx = snapshotCanvas.getContext('2d');
    
    snapshotCanvas.width = video.videoWidth;
    snapshotCanvas.height = video.videoHeight;
    
    // Draw current video frame
    snapshotCtx.drawImage(video, 0, 0);
    
    // Draw the overlay with bounding boxes on top
    snapshotCtx.drawImage(canvas, 0, 0);
    
    // Convert to base64
    return snapshotCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
}

const updateLiveDetectionOverlay = drawDetectionOverlay;



// Enhanced Flange Detection Functions with Unit Selection

function openFlangeDetectionModal() {
    if (!backendConnected) {
        showNotification('Backend is not connected. Please check your connection.', 'error');
        return;
    }
    
    setDetectionType('flange');
    document.getElementById('detectionModal').style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Show unit selector for flange
    showUnitSelector();
}


// FIXED: Unit selector management
function showUnitSelector() {
    let unitSelector = document.getElementById('unitSelector');
    if (!unitSelector) {
        unitSelector = document.createElement('div');
        unitSelector.id = 'unitSelector';
        unitSelector.className = 'unit-selector';
        unitSelector.innerHTML = `
            <div class="unit-selector-header">
                <h4>üìè Select Measurement Unit</h4>
                <p>Choose your preferred unit for flange measurements and compliance checking</p>
            </div>
            <div class="unit-options">
                <button class="unit-btn ${preferredUnit === 'inches' ? 'active' : ''}" 
                        onclick="selectUnit('inches')" data-unit="inches">
                    <div class="unit-icon">üìè</div>
                    <div class="unit-name">Inches</div>
                    <div class="unit-desc">Imperial system (¬±0.125")</div>
                </button>
                <button class="unit-btn ${preferredUnit === 'mm' ? 'active' : ''}" 
                        onclick="selectUnit('mm')" data-unit="mm">
                    <div class="unit-icon">üìê</div>
                    <div class="unit-name">Millimeters</div>
                    <div class="unit-desc">Metric system (¬±3.175mm)</div>
                </button>
            </div>
        `;
        
        // Add unit selector styles
        if (!document.getElementById('unitSelectorStyles')) {
            const style = document.createElement('style');
            style.id = 'unitSelectorStyles';
            style.textContent = `
                .unit-selector {
                    background: white;
                    border-radius: 12px;
                    padding: 1.5rem;
                    margin: 1rem 0;
                    border: 2px solid var(--secondary-emerald);
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                }
                .unit-selector-header {
                    text-align: center;
                    margin-bottom: 1.5rem;
                    padding-bottom: 1rem;
                    border-bottom: 1px solid #e5e7eb;
                }
                .unit-selector-header h4 {
                    margin: 0 0 0.5rem 0;
                    color: var(--gray-800);
                    font-size: 1.25rem;
                }
                .unit-selector-header p {
                    margin: 0;
                    color: var(--gray-600);
                    font-size: 0.875rem;
                }
                .unit-options {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 1rem;
                }
                .unit-btn {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 1.5rem;
                    border: 2px solid #e5e7eb;
                    background: white;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                }
                .unit-btn:hover {
                    border-color: var(--secondary-emerald);
                    background: #f0fdf4;
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                }
                .unit-btn.active {
                    border-color: var(--secondary-emerald);
                    background: var(--secondary-emerald);
                    color: white;
                    box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
                }
                .unit-icon {
                    font-size: 2rem;
                    margin-bottom: 0.75rem;
                }
                .unit-name {
                    font-weight: 600;
                    font-size: 1.125rem;
                    margin-bottom: 0.5rem;
                }
                .unit-desc {
                    font-size: 0.875rem;
                    opacity: 0.8;
                    line-height: 1.4;
                }
                .unit-btn.active .unit-icon,
                .unit-btn.active .unit-name,
                .unit-btn.active .unit-desc {
                    color: white;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Insert unit selector into modal
        const modalBody = document.querySelector('.modal-body');
        const uploadArea = document.getElementById('uploadArea');
        modalBody.insertBefore(unitSelector, uploadArea);
    }
    
    unitSelector.style.display = 'block';
}

function hideUnitSelector() {
    const unitSelector = document.getElementById('unitSelector');
    if (unitSelector) {
        unitSelector.style.display = 'none';
    }
}


function selectUnit(unit) {
    preferredUnit = unit;
    
    // Update active button
    document.querySelectorAll('.unit-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-unit="${unit}"]`).classList.add('active');
    
    showNotification(`Selected unit: ${unit === 'inches' ? 'Inches' : 'Millimeters'}`, 'success');
    
    // Update upload area info
    updateUploadAreaForFlange(unit);
}


function updateUploadAreaForFlange(unit) {
    const uploadArea = document.getElementById('uploadArea');
    const tolerance = unit === 'inches' ? '¬±0.125"' : '¬±3.175mm';
    
    // Remove existing flange info
    const existingInfo = uploadArea.querySelector('.flange-unit-info');
    if (existingInfo) {
        existingInfo.remove();
    }
    
    // Add unit-specific info
    const flangeInfo = document.createElement('div');
    flangeInfo.className = 'flange-unit-info';
    flangeInfo.innerHTML = `
        <div style="margin-top: 1rem; padding: 1rem; background: var(--secondary-emerald); color: white; border-radius: 8px; font-size: 0.875rem;">
            <strong>Unit: ${unit === 'inches' ? 'Inches' : 'Millimeters'}</strong><br>
            Tolerance: ${tolerance}<br>
            ArUco marker required for accurate measurements
        </div>
    `;
    uploadArea.appendChild(flangeInfo);
}

async function detectFlangeWithUnits(file) {
    try {
        showProcessingStatus(`Analyzing flange dimensions in ${preferredUnit}...`);
        
        const formData = new FormData();
        formData.append('image', file);
        formData.append('unit', preferredUnit);
        
        console.log('Sending flange detection request with unit:', preferredUnit);
        
        const response = await fetch(`${API_BASE_URL}/detect_flange_with_units`, {
            method: 'POST',
            body: formData
        });
        
        console.log('Response status:', response.status);
        
        // FIXED: Better error handling
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Backend error:', errorText);
            throw new Error(`Server responded with ${response.status}: ${errorText}`);
        }
        
        const result = await response.json();
        console.log('Response data:', result);
        
        if (result.success) {
            // FIXED: Call the correct display function with proper data
            displayFlangeResults(result);
            showSuccessStatus(`Flange analysis complete in ${preferredUnit}`);
            
            if (result.tolerance_info) {
                const toleranceMsg = `Tolerance applied: ${result.tolerance_info[preferredUnit]}`;
                showNotification(toleranceMsg, 'info');
            }
        } else {
            console.error('Backend error:', result.error);
            showErrorStatus(result.error || 'Flange analysis failed');
        }
        
    } catch (error) {
        console.error('Flange detection error:', error);
        // FIXED: More specific error message
        if (error.message.includes('Failed to fetch')) {
            showErrorStatus('Cannot connect to backend. Is the server running on http://localhost:5000?');
        } else {
            showErrorStatus(`Analysis failed: ${error.message}`);
        }
    }
}


///above chnage new 
// FIXED: Update live defect results with proper frame capture
function updateLiveDefectResults(result) {
    if (result.detections && result.detections.length > 0) {
        // Capture snapshot with bounding boxes at proper size
        const snapshot = captureDefectSnapshot();
        
        result.detections.forEach(detection => {
            const defectRecord = {
                ...detection,
                timestamp: new Date().toISOString(),
                detection_type: currentDetectionType,
                defect_frame: snapshot, // Properly sized snapshot
                live_detection: true,
                frame_snapshot: snapshot
            };
            
            sessionResults.push(defectRecord);
        });

        // Limit stored results
        if (sessionResults.length > 1000) {
            sessionResults = sessionResults.slice(-800);
        }

        displayLiveResults();
    }
}

// Recording Functions
async function startRecording() {
    if (!isLiveDetectionActive) {
        showNotification('Start live camera first', 'warning');
        return;
    }
    
    try {
        const response = await fetch(`${API_BASE_URL}/start_recording`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                detection_type: currentDetectionType
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            isRecording = true;
            showNotification('Recording started', 'success');
        } else {
            showNotification(result.error || 'Failed to start recording', 'error');
        }
        
    } catch (error) {
        console.error('Recording start error:', error);
        showNotification('Failed to start recording', 'error');
    }
}

// ADD THESE NEW FUNCTIONS after the existing functions (around line 400 in your JS file)

function displayVideoPlayer(streamUrl, downloadUrl) {
    const previewContainer = document.querySelector('.detection-area');
    
    // Remove existing video player if present
    const existingVideoPlayer = previewContainer.querySelector('.video-player-container');
    if (existingVideoPlayer) {
        existingVideoPlayer.remove();
    }
    
    // Create video player HTML
    const videoPlayerHTML = `
        <div class="video-player-container" style="margin-top: 1rem;">
            <div class="video-player-header">
                <h4>üìπ Analyzed Video Results</h4>
                <div class="video-controls-info">
                    <span class="video-info-badge">Defects Highlighted</span>
                </div>
            </div>
            <video 
                id="analyzedVideo"
                controls 
                width="100%" 
                style="max-height: 400px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);"
                poster="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 400'%3E%3Crect width='640' height='400' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='18' fill='%23374151'%3EAnalyzed Video%3C/text%3E%3C/svg%3E"
            >
                <source src="${streamUrl}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <div class="video-actions" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                <div class="video-info">
                    <small style="color: #6b7280;">Click play to view analyzed video with defect annotations</small>
                </div>
                <button onclick="window.open('${downloadUrl}', '_blank')" class="btn btn-secondary">
                    üì• Download Video
                </button>
            </div>
        </div>
    `;
    
    // Insert video player
    const placeholder = document.getElementById('placeholder');
    const previewImage = document.getElementById('previewImage');
    
    // Hide placeholder and preview image
    placeholder.style.display = 'none';
    previewImage.classList.add('hidden');
    
    // Add video player to the detection area
    previewContainer.insertAdjacentHTML('beforeend', videoPlayerHTML);
    
    // Add video player styles if not already added
    addVideoPlayerStyles();
}

function addVideoPlayerStyles() {
    if (!document.getElementById('videoPlayerStyles')) {
        const style = document.createElement('style');
        style.id = 'videoPlayerStyles';
        style.textContent = `
            .video-player-container {
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                border: 1px solid #e5e7eb;
            }
            .video-player-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                padding-bottom: 0.75rem;
                border-bottom: 1px solid #e5e7eb;
            }
            .video-player-header h4 {
                margin: 0;
                font-size: 1.25rem;
                font-weight: 600;
                color: #374151;
            }
            .video-info-badge {
                background: var(--primary-main);
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.875rem;
                font-weight: 600;
            }
            .video-actions {
                background: #f9fafb;
                padding: 1rem;
                border-radius: 8px;
                margin-top: 1rem;
            }
            #analyzedVideo {
                background: #000;
                border: 2px solid #e5e7eb;
            }
            #analyzedVideo:hover {
                border-color: var(--primary-main);
                transition: border-color 0.3s ease;
            }
        `;
        document.head.appendChild(style);
    }
}

function aggregateVideoDefects(defects) {
    "Aggregate defects from video analysis with timing information"
    const defectMap = new Map();
    
    defects.forEach(defect => {
        const key = defect.type;
        if (!defectMap.has(key)) {
            defectMap.set(key, {
                type: defect.type,
                count: 0,
                first_detection: defect.video_timestamp || 0,
                last_detection: defect.video_timestamp || 0,
                confidence_avg: 0,
                confidence_max: defect.confidence,
                frame_detections: 0,
                detection_type: defect.detection_type
            });
        }
        
        const existing = defectMap.get(key);
        existing.count += 1;
        existing.frame_detections += (defect.frame_detections || 1);
        existing.confidence_avg = (existing.confidence_avg * (existing.count - 1) + defect.confidence) / existing.count;
        existing.confidence_max = Math.max(existing.confidence_max, defect.confidence);
        existing.last_detection = Math.max(existing.last_detection, defect.video_timestamp || 0);
        existing.first_detection = Math.min(existing.first_detection, defect.video_timestamp || 0);
    });
    
    return Array.from(defectMap.values());
}

async function stopRecording() {
    if (!isRecording) return;
    
    try {
        const response = await fetch(`${API_BASE_URL}/stop_recording`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            isRecording = false;
            showNotification('Recording stopped', 'success');
        }
        
    } catch (error) {
        console.error('Recording stop error:', error);
    }
}

function displayResults(result) {
    const defectList = document.getElementById('defectList');
    defectList.innerHTML = '';
    
    // Check if this is a video result
    if (result.video_info && (result.stream_video_url || result.annotated_video)) {
        displayVideoResults(result);
    } else if (result.annotated_image) {
        showPreviewImage(result.annotated_image);
    }
    
    if (currentDetectionType === 'flange' && result.flange_analysis) {
        displayFlangeResults(result.flange_analysis, defectList);
    } else if (result.defects && result.defects.length > 0) {
        displayDefectResultsWithFrames(result.defects, result.video_info, defectList);
    } else {
        defectList.innerHTML = '<div class="empty-state">No defects detected</div>';
    }
    
    updateInsights(result);
}
 // place one more function which is for anlyzing and can chnaged 

 function displayVideoResults(result) {
    const detectionArea = document.querySelector('.detection-area');
    
    // Remove existing video player
    const existingPlayer = detectionArea.querySelector('.video-player-container');
    if (existingPlayer) existingPlayer.remove();
    
    const videoPlayerHTML = `
        <div class="video-player-container">
            <div class="video-player-header">
                <h4>üé¨ Analyzed Video Results</h4>
                <div class="video-stats">
                    <span class="stat">Duration: ${result.video_info.duration.toFixed(1)}s</span>
                    <span class="stat">Defects: ${result.total_defects}</span>
                    <span class="stat">FPS: ${result.video_info.fps}</span>
                </div>
            </div>
            <video 
                id="analyzedVideo"
                controls 
                width="100%" 
                style="max-height: 400px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);"
            >
                <source src="${result.stream_video_url}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <div class="video-actions">
                <button onclick="window.open('${result.download_video_url}', '_blank')" class="btn btn-primary">
                    üíæ Download Analyzed Video
                </button>
                <button onclick="downloadAllDefectFrames()" class="btn btn-secondary">
                    üì∏ Download All Defect Frames
                </button>
            </div>
        </div>
    `;
    
    // Hide other elements
    document.getElementById('placeholder').style.display = 'none';
    document.getElementById('previewImage').classList.add('hidden');
    
    detectionArea.insertAdjacentHTML('beforeend', videoPlayerHTML);
    addVideoPlayerStyles();
}

////i chnage above program



// ADD THIS NEW FUNCTION for video-specific defect display
function displayVideoDefectResults(defects, videoInfo, container) {
    const aggregatedDefects = aggregateVideoDefects(defects);
    
    // Create video analysis summary
    const videoSummaryHTML = `
        <div class="video-analysis-summary">
            <h4>üìä Video Analysis Summary</h4>
            <div class="video-stats-grid">
                <div class="video-stat">
                    <span class="stat-value">${videoInfo.duration.toFixed(1)}s</span>
                    <span class="stat-label">Duration</span>
                </div>
                <div class="video-stat">
                    <span class="stat-value">${defects.length}</span>
                    <span class="stat-label">Unique Defects</span>
                </div>
                <div class="video-stat">
                    <span class="stat-value">${videoInfo.defect_density_per_minute || 0}</span>
                    <span class="stat-label">Defects/Min</span>
                </div>
                <div class="video-stat">
                    <span class="stat-value">${videoInfo.processed_frames}</span>
                    <span class="stat-label">Frames Analyzed</span>
                </div>
            </div>
        </div>
    `;
    
    // Create defect timeline
    const defectTimelineHTML = aggregatedDefects.map(defect => {
        const severity = getSeverityLevel(defect.type, currentDetectionType);
        const duration = defect.last_detection - defect.first_detection;
        
        return `
            <div class="video-defect-item">
                <div class="defect-timeline-info">
                    <div class="defect-type">${defect.type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
                    <div class="defect-timeline">
                        <span class="timeline-start">First: ${defect.first_detection.toFixed(1)}s</span>
                        ${duration > 0 ? `<span class="timeline-duration">Duration: ${duration.toFixed(1)}s</span>` : ''}
                        <span class="timeline-end">Last: ${defect.last_detection.toFixed(1)}s</span>
                    </div>
                    <div class="defect-stats">
                        <span class="confidence">Max Confidence: ${(defect.confidence_max * 100).toFixed(1)}%</span>
                        <span class="frame-count">Detected in ${defect.frame_detections} frame(s)</span>
                    </div>
                </div>
                <div class="defect-severity-info">
                    <div class="count-number">${defect.count}</div>
                    <div class="severity-badge severity-${severity}">${severity.toUpperCase()}</div>
                </div>
            </div>
        `;
    }).join('');
    
    // Add video defect styles
    addVideoDefectStyles();
    
    container.innerHTML = videoSummaryHTML + defectTimelineHTML;
}

function addVideoDefectStyles() {
    if (!document.getElementById('videoDefectStyles')) {
        const style = document.createElement('style');
        style.id = 'videoDefectStyles';
        style.textContent = `
            .video-analysis-summary {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 1.5rem;
                border-radius: 12px;
                margin-bottom: 1.5rem;
            }
            .video-analysis-summary h4 {
                margin: 0 0 1rem 0;
                font-weight: 600;
            }
            .video-stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 1rem;
            }
            .video-stat {
                text-align: center;
                padding: 1rem;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                backdrop-filter: blur(10px);
            }
            .video-stat .stat-value {
                display: block;
                font-size: 1.75rem;
                font-weight: 700;
                margin-bottom: 0.25rem;
            }
            .video-stat .stat-label {
                font-size: 0.875rem;
                opacity: 0.9;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .video-defect-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                margin-bottom: 1rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                border-left: 4px solid var(--primary-main);
            }
            .defect-timeline-info {
                flex: 1;
            }
            .defect-timeline-info .defect-type {
                font-size: 1.125rem;
                font-weight: 600;
                color: #374151;
                margin-bottom: 0.5rem;
            }
            .defect-timeline {
                display: flex;
                gap: 1rem;
                margin-bottom: 0.5rem;
                flex-wrap: wrap;
            }
            .defect-timeline span {
                background: #f3f4f6;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.875rem;
                color: #6b7280;
                font-weight: 500;
            }
            .timeline-duration {
                background: #fef3c7 !important;
                color: #92400e !important;
            }
            .defect-stats {
                display: flex;
                gap: 1rem;
                font-size: 0.875rem;
                color: #6b7280;
            }
            .defect-severity-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            .defect-severity-info .count-number {
                font-size: 2rem;
                font-weight: 700;
                color: var(--primary-main);
            }
        `;
        document.head.appendChild(style);
    }
}


// Add to your existing JavaScript

function toggleCalibrationSection() {
    const section = document.getElementById('calibrationSection');
    section.classList.toggle('hidden');
}

async function calibrateCamera() {
    const fileInput = document.getElementById('calibrationImages');
    const files = fileInput.files;
    
    if (!files || files.length < 10) {
        showNotification('Please upload at least 10 checkerboard images', 'warning');
        return;
    }
    
    const statusDiv = document.getElementById('calibrationStatus');
    statusDiv.innerHTML = '<p>‚è≥ Calibrating camera... This may take a minute.</p>';
    
    const formData = new FormData();
    for (let i = 0; i < files.length; i++) {
        formData.append('images', files[i]);
    }
    
    try {
        const response = await fetch(`${API_BASE_URL}/calibrate_camera`, {
            method: 'POST',
            body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
            statusDiv.innerHTML = `
                <div style="color: var(--success); padding: 1rem; background: #f0fdf4; border-radius: 8px; margin-top: 1rem;">
                    ‚úÖ Calibration successful!<br>
                    Reprojection error: ${result.reprojection_error.toFixed(4)} pixels<br>
                    Camera is now calibrated for accurate measurements.
                </div>
            `;
            showNotification('Camera calibration successful!', 'success');
        } else {
            statusDiv.innerHTML = `
                <div style="color: var(--error); padding: 1rem; background: #fef2f2; border-radius: 8px; margin-top: 1rem;">
                    ‚ùå ${result.error}
                </div>
            `;
            showNotification('Calibration failed', 'error');
        }
    } catch (error) {
        console.error('Calibration error:', error);
        statusDiv.innerHTML = `
            <div style="color: var(--error); padding: 1rem; background: #fef2f2; border-radius: 8px; margin-top: 1rem;">
                ‚ùå Calibration failed: ${error.message}
            </div>
        `;
    }
}


// ‚úÖ COMPLETE FLANGE RESULTS DISPLAY FUNCTION
function displayFlangeResults(result) {
    const defectList = document.getElementById('defectList');

    // FIXED: Better data extraction with multiple fallbacks
    const analysis = result.flange_analysis || result;
    const measurements = analysis.measurements || {};
    const compliance = analysis.compliance || {};

    // Ensure we have the annotated image
    if (result.annotated_image) {
        const img = result.annotated_image;
        showPreviewImage(img.startsWith('data:') ? img : `data:image/jpeg;base64,${img}`);
    }

    // ===================================================================
    // SECTION 1: VALIDATION CHECK & REJECTION BANNER
    // ===================================================================
    const validationPassed = measurements.validation_passed !== false;
    const validationMessage = measurements.validation_message || '';

    if (!validationPassed) {
        const rejectionHTML = `
            <div class="validation-failed-banner">
                <div class="validation-icon">‚ùå</div>
                <div class="validation-content">
                    <h4>Measurement Rejected - Poor Conditions</h4>
                    <p style="font-size: 1.125rem; margin: 1rem 0; color: #991b1b; font-weight: 600;">
                        ${validationMessage}
                    </p>
                    <div class="validation-actions">
                        <strong>‚úÖ Required Actions:</strong>
                        <ul>
                            <li>üìè Position camera between <strong>30-150cm</strong> from flange</li>
                            <li>üìê Ensure camera is perpendicular (tilt < 25¬∞)</li>
                            <li>üéØ Make sure ArUco marker is clearly visible (>2000px¬≤)</li>
                            <li>üí° Use good, even lighting without shadows</li>
                            <li>üì± For far distances, use a larger ArUco marker (e.g., 10cm)</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        
        defectList.innerHTML = rejectionHTML;
        return; // Stop here - don't show measurements
    }

    // ===================================================================
    // SECTION 2: DISTANCE CORRECTION BANNER
    // ===================================================================
    const distanceCorrection = measurements.distance_correction;
    let correctionHTML = '';

    if (distanceCorrection && distanceCorrection.applied) {
        const confidence = distanceCorrection.confidence_level;
        const color = distanceCorrection.confidence_color || '#10b981';
        const distanceCm = (distanceCorrection.distance_mm / 10).toFixed(1);
        const correctionPercent = ((distanceCorrection.factor - 1) * 100).toFixed(2);
        const correctionApplied = Math.abs(distanceCorrection.factor - 1.0) > 0.01;

        correctionHTML = `
            <div class="distance-correction-banner" style="background: linear-gradient(135deg, #dbeafe, #bfdbfe); border-left: 6px solid ${color}; border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                <div style="display: flex; align-items: flex-start; gap: 1.5rem;">
                    <div style="font-size: 3rem; flex-shrink: 0;">üîß</div>
                    <div style="flex: 1;">
                        <h5 style="margin: 0 0 1rem 0; color: #1e40af; font-size: 1.25rem; font-weight: 700;">
                            ‚ú® Automatic Distance Compensation ${correctionApplied ? 'Applied' : '(No Correction Needed)'}
                        </h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: white; padding: 0.75rem; border-radius: 8px; border-left: 3px solid ${color};">
                                <div style="font-size: 0.75rem; color: #6b7280; text-transform: uppercase; margin-bottom: 0.25rem;">Distance</div>
                                <div style="font-size: 1.25rem; font-weight: 700; color: #1e40af;">${distanceCm}cm</div>
                            </div>
                            <div style="background: white; padding: 0.75rem; border-radius: 8px; border-left: 3px solid ${color};">
                                <div style="font-size: 0.75rem; color: #6b7280; text-transform: uppercase; margin-bottom: 0.25rem;">Correction</div>
                                <div style="font-size: 1.25rem; font-weight: 700; color: ${correctionApplied ? '#1e40af' : '#10b981'};">
                                    ${correctionApplied ? (correctionPercent > 0 ? '+' : '') + correctionPercent + '%' : '0%'}
                                </div>
                            </div>
                            <div style="background: white; padding: 0.75rem; border-radius: 8px; border-left: 3px solid ${color};">
                                <div style="font-size: 0.75rem; color: #6b7280; text-transform: uppercase; margin-bottom: 0.25rem;">Confidence</div>
                                <div style="font-size: 1.25rem; font-weight: 700; color: ${color};">${confidence.toUpperCase()}</div>
                            </div>
                            <div style="background: white; padding: 0.75rem; border-radius: 8px; border-left: 3px solid ${color};">
                                <div style="font-size: 0.75rem; color: #6b7280; text-transform: uppercase; margin-bottom: 0.25rem;">Expected Error</div>
                                <div style="font-size: 1.25rem; font-weight: 700; color: #1e40af;">¬±${distanceCorrection.expected_error_mm}mm</div>
                            </div>
                        </div>
                        ${correctionApplied ? `
                            <details style="background: white; padding: 1rem; border-radius: 8px; border: 1px solid #e5e7eb; cursor: pointer;">
                                <summary style="font-weight: 600; color: #1e40af; cursor: pointer; user-select: none;">
                                    üìä View Before/After Comparison
                                </summary>
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid #e5e7eb;">
                                    <div style="display: grid; gap: 0.75rem; font-size: 0.9rem;">
                                        ${distanceCorrection.original_values.od > 0 ? `
                                            <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #f9fafb; border-radius: 6px;">
                                                <span style="color: #6b7280;">Outer Diameter:</span>
                                                <span style="font-weight: 600; color: #1e40af;">
                                                    <span style="text-decoration: line-through; color: #ef4444;">${distanceCorrection.original_values.od.toFixed(2)}mm</span>
                                                    ‚Üí
                                                    <span style="color: #10b981;">${distanceCorrection.corrected_values.od.toFixed(2)}mm</span>
                                                </span>
                                            </div>
                                        ` : ''}
                                        ${distanceCorrection.original_values.id > 0 ? `
                                            <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #f9fafb; border-radius: 6px;">
                                                <span style="color: #6b7280;">Inner Diameter:</span>
                                                <span style="font-weight: 600; color: #1e40af;">
                                                    <span style="text-decoration: line-through; color: #ef4444;">${distanceCorrection.original_values.id.toFixed(2)}mm</span>
                                                    ‚Üí
                                                    <span style="color: #10b981;">${distanceCorrection.corrected_values.id.toFixed(2)}mm</span>
                                                </span>
                                            </div>
                                        ` : ''}
                                        ${distanceCorrection.original_values.bolt_dia > 0 ? `
                                            <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #f9fafb; border-radius: 6px;">
                                                <span style="color: #6b7280;">Bolt Diameter:</span>
                                                <span style="font-weight: 600; color: #1e40af;">
                                                    <span style="text-decoration: line-through; color: #ef4444;">${distanceCorrection.original_values.bolt_dia.toFixed(2)}mm</span>
                                                    ‚Üí
                                                    <span style="color: #10b981;">${distanceCorrection.corrected_values.bolt_dia.toFixed(2)}mm</span>
                                                </span>
                                            </div>
                                        ` : ''}
                                        ${distanceCorrection.original_values.pcd > 0 ? `
                                            <div style="display: flex; justify-content: space-between; padding: 0.5rem; background: #f9fafb; border-radius: 6px;">
                                                <span style="color: #6b7280;">PCD:</span>
                                                <span style="font-weight: 600; color: #1e40af;">
                                                    <span style="text-decoration: line-through; color: #ef4444;">${distanceCorrection.original_values.pcd.toFixed(2)}mm</span>
                                                    ‚Üí
                                                    <span style="color: #10b981;">${distanceCorrection.corrected_values.pcd.toFixed(2)}mm</span>
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </details>
                        ` : `
                            <div style="background: white; padding: 0.75rem; border-radius: 8px; text-align: center; color: #10b981; font-weight: 600;">
                                ‚úÖ No correction needed - optimal distance!
                            </div>
                        `}
                    </div>
                </div>
            </div>
        `;
    } else if (validationMessage.includes('‚ö†Ô∏è')) {
        // Show warning banner
        correctionHTML = `
            <div class="validation-warning-banner" style="background: #fffbeb; border: 2px solid #f59e0b; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1rem;">
                <div style="font-size: 1.5rem;">‚ö†Ô∏è</div>
                <div style="flex: 1; color: #92400e; font-weight: 600;">${validationMessage}</div>
            </div>
        `;
    }

    // ===================================================================
    // SECTION 3: EXTRACT MEASUREMENTS WITH FALLBACKS
    // ===================================================================
    const outerDia = measurements.outer_dia || measurements.od || measurements.outer_diameter || 0;
    const innerDia = measurements.inner_dia || measurements.id || measurements.inner_diameter || 0;
    const boltDia = measurements.bolt_dia || measurements.bolt_diameter || measurements.bd || 0;
    const pcd = measurements.pcd || measurements.PCD || 0;
    const boltCount = measurements.bolt_count || measurements.bolts || 0;
    
    const outerDiaPx = measurements.od_px || measurements.outer_dia_px || 0;
    const innerDiaPx = measurements.id_px || measurements.inner_dia_px || 0;
    const boltDiaPx = measurements.bolt_dia_px || measurements.bolt_diameter_px || 0;
    
    const hasScale = measurements.px_to_mm !== null && measurements.px_to_mm !== undefined;
    const unit = measurements.unit || analysis.unit || preferredUnit || 'mm';
    const unitSymbol = unit === 'inches' ? '"' : 'mm';

    // ===================================================================
    // SECTION 4: ACCURACY METRICS
    // ===================================================================
    const calibrationActive = analysis.calibration_active || measurements.calibration_active || false;
    const measurementQuality = analysis.measurement_quality || measurements.quality || 'unknown';
    const reprojectionError = analysis.reprojection_error_mm || measurements.reprojection_error_mm;

    const qualityColors = {
        'excellent': { color: '#10b981', icon: 'üéØ', text: 'Excellent' },
        'good': { color: '#22c55e', icon: '‚úÖ', text: 'Good' },
        'fair': { color: '#f59e0b', icon: '‚ö†Ô∏è', text: 'Fair' },
        'acceptable': { color: '#fb923c', icon: '‚ö†Ô∏è', text: 'Acceptable' },
        'poor': { color: '#ef4444', icon: '‚ùå', text: 'Poor' },
        'unknown': { color: '#6b7280', icon: '‚ÑπÔ∏è', text: 'Unknown' }
    };
    const qualityInfo = qualityColors[measurementQuality] || qualityColors['unknown'];

    // ===================================================================
    // SECTION 5: DISTANCE INFORMATION
    // ===================================================================
    const distanceInfo = analysis.measurement_conditions || measurements.measurement_conditions || null;

    // ===================================================================
    // SECTION 6: TOLERANCE DISPLAY
    // ===================================================================
    const toleranceValue = unit === 'inches' ? '0.125"' : '3.175mm';
    const toleranceInfo = result.tolerance_info ? result.tolerance_info[unit] : `¬±${toleranceValue}`;

    // ===================================================================
    // SECTION 7: BUILD COMPLETE HTML
    // ===================================================================
    const flangeHTML = correctionHTML + `
        <div class="flange-detailed-results">
            
            <!-- ACCURACY STATUS BANNER -->
            <div class="accuracy-banner ${measurementQuality}">
                <div class="accuracy-main">
                    <div class="accuracy-icon">${qualityInfo.icon}</div>
                    <div class="accuracy-info">
                        <div class="accuracy-title">Measurement Quality: ${qualityInfo.text.toUpperCase()}</div>
                        <div class="accuracy-details">
                            ${calibrationActive ? 
                                '<span class="status-badge success">üì∑ Camera Calibrated</span>' : 
                                '<span class="status-badge warning">‚ö†Ô∏è Auto-Calibrated</span>'
                            }
                            ${hasScale ? 
                                '<span class="status-badge success">üéØ ArUco Scale Active</span>' : 
                                '<span class="status-badge error">‚ùå No Scale Reference</span>'
                            }
                            ${reprojectionError !== null && reprojectionError !== undefined ? 
                                `<span class="status-badge ${reprojectionError < 1.0 ? 'success' : 'warning'}">
                                    üìä Error: ${reprojectionError.toFixed(3)}mm
                                </span>` : 
                                ''
                            }
                        </div>
                    </div>
                </div>
                ${reprojectionError !== null && reprojectionError > 1.0 ? `
                    <div class="accuracy-warning">
                        ‚ö†Ô∏è Reprojection error exceeds 1.0mm - measurements may be less reliable
                    </div>
                ` : ''}
            </div>

            <!-- DISTANCE INFORMATION CARD -->
            ${distanceInfo && distanceInfo.distance_mm ? `
                <div class="distance-info-card ${distanceInfo.quality}">
                    <h5>üìè Camera Distance & Quality</h5>
                    <div class="distance-metric">
                        <span class="distance-value">${distanceInfo.distance_mm.toFixed(0)}mm</span>
                        <span class="distance-label">(${(distanceInfo.distance_mm / 10).toFixed(1)}cm)</span>
                    </div>
                    <div class="quality-indicator quality-${distanceInfo.quality}">
                        ${distanceInfo.quality.toUpperCase()}
                    </div>
                    <div class="distance-warning">
                        ${distanceInfo.warning || '‚úÖ Optimal measurement conditions'}
                    </div>
                    ${distanceInfo.quality !== 'excellent' && distanceInfo.quality !== 'good' ? `
                        <div class="distance-recommendation">
                            üí° <strong>Recommended:</strong> 40-100cm distance, perpendicular view for best accuracy
                        </div>
                    ` : ''}
                </div>
            ` : ''}

            <!-- UNIT DISPLAY -->
            <div class="unit-display">
                <span class="unit-badge ${unit}">${unit === 'inches' ? 'Imperial (Inches)' : 'Metric (Millimeters)'}</span>
                <span class="tolerance-info">
                    Applied Tolerance: ${toleranceInfo}
                </span>
            </div>

            <!-- MEASUREMENT SECTION -->
            <div class="measurement-section">
                <h4>üìè Dimensional Measurements</h4>
                <div class="measurement-grid">
                    <!-- OUTER DIAMETER -->
                    <div class="measurement-card">
                        <div class="measure-label">Outer Diameter (OD)</div>
                        <div class="measure-value">
                            ${hasScale && outerDia > 0 ? 
                                `${outerDia.toFixed(3)}${unitSymbol}` : 
                                (outerDiaPx > 0 ? `${Math.round(outerDiaPx)}px` : '‚Äî')}
                        </div>
                        <div class="measure-status ${compliance.details?.od_status?.toLowerCase() || (outerDia > 0 ? 'pass' : 'unknown')}">
                            ${compliance.details?.od_status || (outerDia > 0 ? 'DETECTED' : 'NOT FOUND')}
                        </div>
                    </div>

                    <!-- INNER DIAMETER -->
                    <div class="measurement-card">
                        <div class="measure-label">Inner Diameter (ID)</div>
                        <div class="measure-value">
                            ${hasScale && innerDia > 0 ? 
                                `${innerDia.toFixed(3)}${unitSymbol}` : 
                                (innerDiaPx > 0 ? `${Math.round(innerDiaPx)}px` : '‚Äî')}
                        </div>
                        <div class="measure-status ${compliance.details?.id_status?.toLowerCase() || (innerDia > 0 ? 'pass' : 'unknown')}">
                            ${compliance.details?.id_status || (innerDia > 0 ? 'DETECTED' : 'NOT FOUND')}
                        </div>
                    </div>

                    <!-- BOLT DIAMETER -->
                    <div class="measurement-card">
                        <div class="measure-label">Bolt Hole Diameter</div>
                        <div class="measure-value">
                            ${hasScale && boltDia > 0 ? 
                                `${boltDia.toFixed(3)}${unitSymbol}` : 
                                (boltDiaPx > 0 ? `${Math.round(boltDiaPx)}px` : '‚Äî')}
                        </div>
                        <div class="measure-status ${compliance.details?.bolt_dia_status?.toLowerCase() || (boltDia > 0 ? 'pass' : 'unknown')}">
                            ${compliance.details?.bolt_dia_status || (boltDia > 0 ? 'DETECTED' : 'NOT FOUND')}
                        </div>
                    </div>

                    <!-- BOLT COUNT -->
                    <div class="measurement-card">
                        <div class="measure-label">Bolt Count</div>
                        <div class="measure-value">${boltCount}</div>
                        <div class="measure-status ${boltCount > 0 ? 'pass' : 'unknown'}">
                            ${boltCount > 0 ? 'DETECTED' : 'NOT FOUND'}
                        </div>
                    </div>

                    <!-- PCD -->
                    <div class="measurement-card">
                        <div class="measure-label">PCD (Pitch Circle Diameter)</div>
                        <div class="measure-value">
                            ${hasScale && pcd > 0 ? 
                                `${pcd.toFixed(3)}${unitSymbol}` : 
                                (pcd > 0 ? `${Math.round(pcd)}px` : '‚Äî')}
                        </div>
                        <div class="measure-status ${pcd > 0 ? 'pass' : 'unknown'}">
                            ${pcd > 0 ? 'CALCULATED' : 'N/A'}
                        </div>
                        ${pcd > 0 && boltCount >= 3 ? 
                            `<div class="measure-note">Best-fit circle (${boltCount} bolts)</div>` : 
                            (pcd > 0 && boltCount === 2 ? 
                                '<div class="measure-note">Direct distance (2 bolts)</div>' : 
                                ''
                            )
                        }
                    </div>
                </div>
            </div>

            <!-- COMPLIANCE SECTION -->
            <div class="compliance-section">
                <h4>‚úÖ Specification Compliance</h4>
                <div class="compliance-card ${compliance.status || 'unknown'}">
                    <div class="compliance-header">
                        <span class="compliance-icon">
                            ${compliance.status === 'pass' ? '‚úÖ' : 
                              compliance.status === 'fail' ? '‚ùå' : '‚ö†Ô∏è'}
                        </span>
                        <span class="compliance-status">
                            ${(compliance.status || 'UNKNOWN').toUpperCase()}
                        </span>
                    </div>
                    <div class="compliance-message">
                        ${compliance.message || 'No compliance message available'}
                    </div>
                    
                    ${compliance.nps ? `
                        <div class="spec-details">
                            <strong>Specification:</strong> NPS ${compliance.nps}<br>
                            <strong>Applied Tolerance:</strong> ${toleranceInfo}
                        </div>
                    ` : ''}
                </div>
            </div>

            <!-- SCALE INFO -->
            <div class="scale-info">
                ${hasScale ? 
                    `<div class="scale-success">
                        ‚úÖ ArUco marker detected - accurate measurements available
                        ${calibrationActive ? '<br>üî¨ Camera calibration active for maximum accuracy' : ''}
                    </div>` :
                    `<div class="scale-warning">
                        ‚ö†Ô∏è No ArUco marker detected - pixel measurements only<br>
                        Place a 4.8cm ArUco marker in the image for real-world measurements
                        ${!calibrationActive ? '<br>üí° Consider camera calibration for best results' : ''}
                    </div>`
                }
            </div>

            <!-- MEASUREMENT HELP -->
            ${!hasScale && (outerDia > 0 || innerDia > 0 || boltDia > 0) ? `
                <div class="measurement-help">
                    <h5>üí° Measurement Help</h5>
                    <p>Measurements detected but shown in pixels only. For accurate dimensional analysis:</p>
                    <ul>
                        <li>Place a 4.8cm ArUco marker visible in the image</li>
                        <li>Ensure the marker is clearly visible and not obstructed</li>
                        <li>The marker should be on the same plane as the flange</li>
                        <li>Use multiple markers (2-3) around the flange for best results</li>
                        ${!calibrationActive ? '<li>‚≠ê <strong>Recommended:</strong> Calibrate your camera using checkerboard pattern for maximum accuracy</li>' : ''}
                    </ul>
                </div>
            ` : ''}

        </div>
    `;

    // Add enhanced styles
    addEnhancedFlangeStyles();
    
    // Set the HTML
    defectList.innerHTML = flangeHTML;

    // Update insights
    updateFlangeInsights({measurements, compliance}, unit, hasScale, toleranceInfo, {
        quality: measurementQuality,
        calibrationActive,
        reprojectionError,
        warnings: [],
        distanceInfo
    });
}


// ‚úÖ UPDATED: Add enhanced styles for accuracy indicators + measurement visualization
function addEnhancedFlangeStyles() {
    if (!document.getElementById('enhancedFlangeStyles')) {
        const style = document.createElement('style');
        style.id = 'enhancedFlangeStyles';
        style.textContent = `
            .flange-detailed-results { padding: 1rem 0; }

            /* NEW: Accuracy Banner Styles */
            .accuracy-banner {
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                margin-bottom: 1.5rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                border-left: 6px solid;
            }
            .accuracy-banner.excellent { border-left-color: #10b981; }
            .accuracy-banner.good { border-left-color: #22c55e; }
            .accuracy-banner.fair { border-left-color: #f59e0b; }
            .accuracy-banner.poor { border-left-color: #ef4444; }
            .accuracy-banner.unknown { border-left-color: #6b7280; }

            .accuracy-main {
                display: flex;
                align-items: center;
                gap: 1rem;
            }
            .accuracy-icon {
                font-size: 2.5rem;
                flex-shrink: 0;
            }
            .accuracy-info {
                flex: 1;
            }
            .accuracy-title {
                font-size: 1.25rem;
                font-weight: 700;
                color: var(--gray-800);
                margin-bottom: 0.5rem;
            }
            .accuracy-details {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .status-badge {
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.75rem;
                font-weight: 600;
                white-space: nowrap;
            }
            .status-badge.success {
                background: #d1fae5;
                color: #065f46;
            }
            .status-badge.warning {
                background: #fef3c7;
                color: #92400e;
            }
            .status-badge.error {
                background: #fee2e2;
                color: #991b1b;
            }
            .accuracy-warning {
                margin-top: 1rem;
                padding: 0.75rem;
                background: #fffbeb;
                border-radius: 6px;
                color: #92400e;
                font-size: 0.875rem;
                border-left: 3px solid #f59e0b;
            }

            /* NEW: Warnings Section */
            .warnings-section {
                background: #fffbeb;
                border-radius: 12px;
                padding: 1.5rem;
                margin: 1.5rem 0;
                border-left: 4px solid #f59e0b;
            }
            .warnings-section h4 {
                margin: 0 0 1rem 0;
                color: #92400e;
                font-size: 1.125rem;
            }
            .warnings-list {
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
            }
            .warning-item {
                display: flex;
                align-items: flex-start;
                gap: 0.75rem;
                padding: 0.75rem;
                background: white;
                border-radius: 6px;
                border-left: 3px solid #f59e0b;
            }
            .warning-icon {
                font-size: 1.25rem;
                flex-shrink: 0;
            }
            .warning-text {
                flex: 1;
                color: #78350f;
                line-height: 1.5;
            }

            /* NEW: Improvement Tips */
            .improvement-tips {
                background: linear-gradient(135deg, #f0f9ff, #e0e7ff);
                border-radius: 12px;
                padding: 1.5rem;
                margin-top: 1.5rem;
                border: 2px solid var(--primary-light);
            }
            .improvement-tips h5 {
                margin: 0 0 1rem 0;
                color: var(--primary-dark);
                font-size: 1.125rem;
            }
            .tips-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
            }
            .tip-card {
                background: white;
                border-radius: 8px;
                padding: 1rem;
                border-left: 3px solid var(--primary-main);
                display: flex;
                gap: 0.75rem;
            }
            .tip-icon {
                font-size: 1.5rem;
                flex-shrink: 0;
            }
            .tip-content {
                flex: 1;
            }
            .tip-content strong {
                display: block;
                color: var(--gray-800);
                margin-bottom: 0.25rem;
                font-size: 0.9rem;
            }
            .tip-content p {
                margin: 0;
                color: var(--gray-600);
                font-size: 0.8rem;
                line-height: 1.4;
            }

            /* NEW: Measurement Note */
            .measure-note {
                margin-top: 0.5rem;
                font-size: 0.75rem;
                color: var(--gray-500);
                font-style: italic;
                text-align: center;
            }

            /* Existing styles... */
            .unit-display {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1.5rem;
                padding: 1rem;
                background: linear-gradient(135deg, var(--secondary-emerald), #34d399);
                border-radius: 8px;
                color: white;
            }
            .unit-badge {
                font-weight: 600;
                font-size: 1.125rem;
            }
            .tolerance-info {
                font-size: 0.875rem;
                opacity: 0.9;
            }

            .measurement-section, .compliance-section {
                margin-bottom: 2rem;
            }
            .measurement-section h4, .compliance-section h4 {
                margin-bottom: 1rem;
                font-weight: 600;
                color: var(--gray-800);
                font-size: 1.25rem;
            }

            .measurement-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
            }
            .measurement-card {
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                border: 1px solid #e5e7eb;
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                text-align: center;
                transition: transform 0.2s ease, box-shadow 0.2s ease;
                position: relative;
                overflow: visible;
            }
            .measurement-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            }

            /* ‚úÖ NEW: Enhanced measurement visualization */
            .measurement-card::before {
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 14px;
                background: linear-gradient(135deg, transparent, rgba(5, 150, 105, 0.1));
                z-index: -1;
                opacity: 0;
                transition: opacity 0.3s;
            }
            .measurement-card:hover::before {
                opacity: 1;
            }

            /* ‚úÖ Edge-based detection indicator */
            .measure-value::after {
                content: 'üéØ';
                font-size: 0.875rem;
                margin-left: 0.5rem;
                opacity: 0.6;
            }

            .measure-label {
                font-size: 0.875rem;
                color: var(--gray-600);
                margin-bottom: 0.5rem;
                font-weight: 500;
            }
            .measure-value {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--gray-800);
                margin-bottom: 0.75rem;
            }
            .measure-status {
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.75rem;
                font-weight: 600;
                text-transform: uppercase;
            }
            .measure-status.pass { background: var(--success); color: white; }
            .measure-status.fail { background: var(--error); color: white; }
            .measure-status.unknown { background: var(--warning); color: white; }

            .compliance-card {
                background: white;
                border-radius: 12px;
                padding: 2rem;
                border-left: 6px solid;
            }
            .compliance-card.pass { border-left-color: var(--success); }
            .compliance-card.fail { border-left-color: var(--error); }
            .compliance-card.unknown { border-left-color: var(--warning); }

            .compliance-header {
                display: flex;
                align-items: center;
                gap: 1rem;
                margin-bottom: 1rem;
            }
            .compliance-icon { font-size: 1.5rem; }
            .compliance-status {
                font-size: 1.25rem;
                font-weight: 700;
            }
            .compliance-card.pass .compliance-status { color: var(--success); }
            .compliance-card.fail .compliance-status { color: var(--error); }
            .compliance-card.unknown .compliance-status { color: var(--warning); }

            .compliance-message {
                color: var(--gray-700);
                margin-bottom: 1.5rem;
                font-weight: 500;
                line-height: 1.6;
            }

            .spec-details {
                background: var(--gray-50);
                padding: 1rem;
                border-radius: 6px;
                line-height: 1.8;
            }

            .scale-info { margin-top: 1.5rem; }
            .scale-success {
                padding: 1rem;
                background: #f0fdf4;
                color: var(--success);
                border-radius: 8px;
                font-weight: 500;
                border-left: 4px solid var(--success);
                line-height: 1.6;
            }
            .scale-warning {
                padding: 1rem;
                background: #fffbeb;
                color: #92400e;
                border-radius: 8px;
                font-weight: 500;
                border-left: 4px solid var(--warning);
                line-height: 1.6;
            }

            .measurement-help {
                background: linear-gradient(135deg, #f0f9ff, #e0e7ff);
                border: 1px solid var(--primary-light);
                border-radius: 12px;
                padding: 1.5rem;
                margin-top: 1.5rem;
            }
            .measurement-help h5 {
                color: var(--primary-main);
                font-size: 1.125rem;
                font-weight: 600;
                margin: 0 0 0.75rem 0;
            }
            .measurement-help p {
                margin: 0 0 0.75rem 0;
                color: var(--gray-700);
                line-height: 1.6;
            }
            .measurement-help ul {
                list-style: none;
                padding-left: 0;
                margin: 0;
            }
            .measurement-help li {
                display: flex;
                align-items: flex-start;
                gap: 0.5rem;
                margin-bottom: 0.5rem;
                color: var(--gray-700);
                line-height: 1.5;
            }
            .measurement-help li::before {
                content: "‚Ä¢";
                color: var(--primary-main);
                font-weight: bold;
                font-size: 1.25rem;
                flex-shrink: 0;
            }

            /* Responsive adjustments */
            @media (max-width: 768px) {
                .accuracy-main {
                    flex-direction: column;
                    text-align: center;
                }
                .accuracy-details {
                    justify-content: center;
                }
                .measurement-grid {
                    grid-template-columns: 1fr;
                }
                .tips-grid {
                    grid-template-columns: 1fr;
                }
            }
        `;
        document.head.appendChild(style);
    }
}





// UPDATED: Enhanced insights function with quality metrics
function updateFlangeInsights(analysis, unit, hasScale, toleranceInfo, qualityMetrics = {}) {
    const insightsContent = document.getElementById('insightsContent');
    const measurements = analysis.measurements || {};
    const compliance = analysis.compliance || {};
    const unitSymbol = unit === 'inches' ? '"' : 'mm';

    const { quality, calibrationActive, reprojectionError, warnings } = qualityMetrics;

    let insights = '';

    // Start with quality assessment
    if (quality) {
        const qualityDescriptions = {
            'excellent': 'Excellent measurement quality (¬±0.5mm typical)',
            'good': 'Good measurement quality (¬±0.5-1.0mm)',
            'fair': 'Fair measurement quality (¬±1.0-2.0mm)',
            'poor': 'Poor measurement quality (>2.0mm error)'
        };
        insights += `${qualityDescriptions[quality] || 'Measurement quality unknown'}. `;
    }

    // Calibration status
    if (calibrationActive) {
        insights += 'Camera calibration active for maximum accuracy. ';
    } else {
        insights += 'Using auto-calibration from ArUco marker. For best results, perform full camera calibration. ';
    }

    // Always show tolerance information first
    insights += `Tolerance Applied: ${toleranceInfo || (unit === 'inches' ? '¬±0.125"' : '¬±3.175mm')}. `;

    if (!hasScale) {
        insights += `No ArUco scale marker detected. Measurements are in pixels only. `;
        
        const outerDetected = (measurements.outer_dia || measurements.od || 0) > 0;
        const innerDetected = (measurements.inner_dia || measurements.id || 0) > 0;
        const boltsDetected = (measurements.bolt_count || 0) > 0;
        const pcdCalculated = (measurements.pcd || 0) > 0;
        
        if (outerDetected || innerDetected || boltsDetected) {
            insights += `Detected components: `;
            const detected = [];
            if (outerDetected) detected.push('outer diameter');
            if (innerDetected) detected.push('inner diameter');
            if (boltsDetected) detected.push(`${measurements.bolt_count} bolt holes`);
            if (pcdCalculated) detected.push('PCD calculated');
            
            insights += detected.join(', ') + '. ';
            insights += `Place a 4.8cm ArUco marker in the image for accurate ${unit} measurements and compliance checking.`;
        } else {
            insights += `No flange components detected. Ensure the image clearly shows the flange and consider adjusting lighting or camera position.`;
        }
        
    } else if (compliance.status === 'pass') {
        insights += `Flange meets specification requirements. `;
        const od = measurements.outer_dia || measurements.od || 0;
        const id = measurements.inner_dia || measurements.id || 0;
        const bolts = measurements.bolt_count || 0;
        const pcd = measurements.pcd || 0;
        
        insights += `Measured: OD ${od.toFixed(3)}${unitSymbol}, ID ${id.toFixed(3)}${unitSymbol}, ${bolts} bolts`;
        if (pcd > 0) {
            insights += `, PCD ${pcd.toFixed(3)}${unitSymbol}`;
        }
        
        if (compliance.nps) {
            insights += ` (NPS ${compliance.nps})`;
        }
        
        insights += '. Component is suitable for installation.';
        
        // Add quality note if applicable
        if (reprojectionError && reprojectionError < 0.5) {
            insights += ' High-precision measurements achieved.';
        }
        
    } else if (compliance.status === 'fail') {
        insights += `Flange does not meet specification requirements. `;
        
        if (compliance.deviations) {
            const issues = [];
            const deviations = compliance.deviations;
            if (Math.abs(deviations.od || 0) > 0.1) {
                issues.push(`OD deviation: ${deviations.od > 0 ? '+' : ''}${deviations.od?.toFixed(3)}${unitSymbol}`);
            }
            if (Math.abs(deviations.id || 0) > 0.1) {
                issues.push(`ID deviation: ${deviations.id > 0 ? '+' : ''}${deviations.id?.toFixed(3)}${unitSymbol}`);
            }
            if (Math.abs(deviations.bolt_dia || 0) > 0.05) {
                issues.push(`Bolt hole deviation: ${deviations.bolt_dia > 0 ? '+' : ''}${deviations.bolt_dia?.toFixed(3)}${unitSymbol}`);
            }
            if (Math.abs(deviations.pcd || 0) > 0.1) {
                issues.push(`PCD deviation: ${deviations.pcd > 0 ? '+' : ''}${deviations.pcd?.toFixed(3)}${unitSymbol}`);
            }
            
            if (issues.length > 0) {
                insights += `Critical deviations: ${issues.join(', ')}. `;
            }
        }
        
        if (compliance.nps) {
            insights += `Specification: NPS ${compliance.nps}. `;
        }
        
        insights += `Review measurements and consider reworking the component. `;
        
        // Add accuracy note if relevant
        if (reprojectionError && reprojectionError > 1.0) {
            insights += `Note: Measurement accuracy may be affected by high reprojection error (${reprojectionError.toFixed(3)}mm). Consider recalibrating or adjusting marker placement.`;
        }
        
    } else {
        insights += `Flange analysis completed but compliance status unclear. `;
        
        const outerDetected = (measurements.outer_dia || measurements.od || 0) > 0;
        const innerDetected = (measurements.inner_dia || measurements.id || 0) > 0;
        const boltsDetected = (measurements.bolt_count || 0) > 0;
        const pcdCalculated = (measurements.pcd || 0) > 0;
        
        if (outerDetected || innerDetected || boltsDetected) {
            const detected = [];
            if (outerDetected) detected.push(`OD: ${measurements.outer_dia?.toFixed(3)}${unitSymbol}`);
            if (innerDetected) detected.push(`ID: ${measurements.inner_dia?.toFixed(3)}${unitSymbol}`);
            if (boltsDetected) detected.push(`${measurements.bolt_count} bolts`);
            if (pcdCalculated) detected.push(`PCD: ${measurements.pcd?.toFixed(3)}${unitSymbol}`);
            
            insights += `Detected measurements: ${detected.join(', ')}. `;
        }
        
        insights += `Ensure flange specification standards are properly loaded for compliance checking.`;
    }

    // Add warnings summary if present
    if (warnings && warnings.length > 0) {
        insights += ` ‚ö†Ô∏è ${warnings.length} warning${warnings.length > 1 ? 's' : ''} detected - review measurement quality section for details.`;
    }

    insightsContent.textContent = insights;
}




//////at this point i am addding new function and 
function displayDefectResultsWithFrames(defects, videoInfo, container) {
    const defectHTML = defects.map((defect, index) => {
        const severity = getSeverityLevel(defect.type, defect.detection_type);
        const timeInfo = defect.video_timestamp ? 
            `Time: ${defect.video_timestamp.toFixed(1)}s | Frame: ${defect.frame_number}` : 
            `Detection ${index + 1}`;
        
        return `
            <div class="defect-item-enhanced">
                <div class="defect-main-info">
                    <div class="defect-header">
                        <div class="defect-type">${defect.type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
                        <div class="defect-confidence">${(defect.confidence * 100).toFixed(1)}%</div>
                        <div class="severity-badge severity-${severity}">${severity.toUpperCase()}</div>
                    </div>
                    <div class="defect-details">
                        <span class="detail-item">${timeInfo}</span>
                        <span class="detail-item">Location: (${defect.location.center_x}, ${defect.location.center_y})</span>
                    </div>
                </div>
                ${defect.defect_frame ? `
                    <div class="defect-frame-preview">
                        <img src="data:image/jpeg;base64,${defect.defect_frame}" 
                             alt="${defect.type}" 
                             class="defect-thumbnail"
                             onclick="showDefectFrame('${defect.defect_frame}', '${defect.type}', '${defect.id}')"
                             title="Click to view full size">
                        <div class="frame-actions">
                            <button onclick="downloadDefectFrame('${defect.id}', '${defect.type}')" 
                                    class="btn-mini">
                                üíæ Download Frame
                            </button>
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    // Add enhanced defect styles
    addEnhancedDefectStyles();
    
    container.innerHTML = defectHTML;
}

function addEnhancedDefectStyles() {
    if (!document.getElementById('enhancedDefectStyles')) {
        const style = document.createElement('style');
        style.id = 'enhancedDefectStyles';
        style.textContent = `
            .defect-item-enhanced {
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 1rem;
                background: white;
                border-radius: 12px;
                margin-bottom: 1rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                border-left: 4px solid var(--primary-main);
            }
            .defect-main-info {
                flex: 1;
            }
            .defect-header {
                display: flex;
                align-items: center;
                gap: 1rem;
                margin-bottom: 0.5rem;
            }
            .defect-header .defect-type {
                font-size: 1.125rem;
                font-weight: 600;
                color: var(--gray-800);
            }
            .defect-confidence {
                background: var(--primary-main);
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.875rem;
                font-weight: 600;
            }
            .defect-details {
                display: flex;
                gap: 1rem;
                font-size: 0.875rem;
                color: var(--gray-600);
                flex-wrap: wrap;
            }
            .defect-frame-preview {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            .defect-thumbnail {
                width: 120px;
                height: 80px;
                object-fit: cover;
                border-radius: 8px;
                cursor: pointer;
                border: 2px solid var(--gray-200);
                transition: all 0.3s ease;
            }
            .defect-thumbnail:hover {
                border-color: var(--primary-main);
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            }
            .btn-mini {
                padding: 0.25rem 0.75rem;
                font-size: 0.75rem;
                border: 1px solid var(--gray-300);
                background: white;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s;
            }
            .btn-mini:hover {
                background: var(--gray-50);
                border-color: var(--primary-main);
            }
        `;
        document.head.appendChild(style);
    }
}


// FIXED: Show defect frame modal with proper sizing
function showDefectFrame(frameData, defectType, defectId) {
    const modal = document.createElement('div');
    modal.className = 'defect-frame-modal';
    modal.innerHTML = `
        <div class="defect-frame-overlay" onclick="closeDefectFrameModal(this)">
            <div class="defect-frame-container" onclick="event.stopPropagation()">
                <div class="defect-frame-header">
                    <h3>üîç ${defectType.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</h3>
                    <button onclick="closeDefectFrameModal(this)" class="close-btn">‚úï</button>
                </div>
                <div class="defect-frame-image-container">
                    <img src="data:image/jpeg;base64,${frameData}" alt="${defectType}" class="defect-frame-full">
                </div>
                <div class="defect-frame-actions">
                    <button onclick="downloadDefectFrame('${defectId}', '${defectType}')" class="btn btn-primary">
                        üíæ Download This Frame
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Add enhanced modal styles
    if (!document.getElementById('defectFrameModalStyles')) {
        const style = document.createElement('style');
        style.id = 'defectFrameModalStyles';
        style.textContent = `
            .defect-frame-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 1005;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .defect-frame-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2rem;
            }
            
            .defect-frame-container {
                background: white;
                border-radius: 12px;
                max-width: 90vw;
                max-height: 90vh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                box-shadow: 0 25px 50px rgba(0,0,0,0.25);
            }
            
            .defect-frame-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid var(--gray-200);
                background: var(--gray-50);
            }
            
            .defect-frame-header h3 {
                margin: 0;
                font-size: 1.25rem;
                color: var(--gray-800);
            }
            
            .close-btn {
                background: none;
                border: none;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 0.5rem;
                border-radius: 4px;
                color: var(--gray-600);
                transition: all 0.2s;
            }
            
            .close-btn:hover {
                background: var(--gray-200);
                color: var(--gray-800);
            }
            
            .defect-frame-image-container {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 1rem;
                background: #f8fafc;
            }
            
            .defect-frame-full {
                max-width: 100%;
                max-height: 60vh;
                object-fit: contain;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            }
            
            .defect-frame-actions {
                padding: 1rem;
                text-align: center;
                border-top: 1px solid var(--gray-200);
                background: white;
            }
            
            @media (max-width: 768px) {
                .defect-frame-overlay {
                    padding: 1rem;
                }
                
                .defect-frame-container {
                    max-width: 95vw;
                    max-height: 95vh;
                }
                
                .defect-frame-full {
                    max-height: 50vh;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(modal);
}



function closeDefectFrameModal(element) {
    const modal = element.closest('.defect-frame-modal');
    if (modal) {
        document.body.removeChild(modal);
    }
}

async function downloadDefectFrame(defectId, defectType) {
    try {
        const response = await fetch(`${API_BASE_URL}/download_defect_frame/${defectId}`, {
            method: 'GET'
        });
        
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `defect_${defectType}_${defectId}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showNotification(`Defect frame downloaded: ${defectType}`, 'success');
        } else {
            throw new Error('Download failed');
        }
    } catch (error) {
        console.error('Download error:', error);
        showNotification('Failed to download defect frame', 'error');
    }
}

async function downloadAllDefectFrames() {
    try {
        // Get all defects with frames from current session
        const response = await fetch(`${API_BASE_URL}/get_session_results`);
        const result = await response.json();
        
        if (result.success && result.all_detections) {
            const defectsWithFrames = result.all_detections.filter(d => d.defect_frame);
            
            if (defectsWithFrames.length === 0) {
                showNotification('No defect frames available for download', 'warning');
                return;
            }
            
            showNotification(`Downloading ${defectsWithFrames.length} defect frames...`, 'info');
            
            // Download each frame with a small delay to avoid overwhelming the browser
            for (let i = 0; i < defectsWithFrames.length; i++) {
                const defect = defectsWithFrames[i];
                await downloadDefectFrame(defect.id, defect.type);
                
                // Small delay between downloads
                if (i < defectsWithFrames.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            showNotification(`Successfully downloaded ${defectsWithFrames.length} defect frames`, 'success');
        }
    } catch (error) {
        console.error('Bulk download error:', error);
        showNotification('Failed to download defect frames', 'error');
    }
}


//////above is new function 








function displayDefectResults(defects, container) {
    const defectCounts = {};
    defects.forEach(defect => {
        defectCounts[defect.type] = (defectCounts[defect.type] || 0) + 1;
    });
    
    const defectHTML = Object.entries(defectCounts).map(([type, count]) => {
        const severity = getSeverityLevel(type, currentDetectionType);
        return `
            <div class="defect-item">
                <div class="defect-info">
                    <div class="defect-type">${type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
                    <div class="defect-details">Confidence: ${(defects.find(d => d.type === type)?.confidence * 100 || 0).toFixed(1)}%</div>
                    <div class="defect-location">Total occurrences in analysis</div>
                </div>
                <div class="defect-count">
                    <div class="count-number">${count}</div>
                    <div class="severity-badge severity-${severity}">${severity}</div>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = defectHTML;
}

// FIXED: Complete displayMultipleResults function to show all annotated images
function displayMultipleResults(result) {
    const defectList = document.getElementById('defectList');
    
    // Create summary section
    const summaryHTML = `
        <div class="multi-results-summary">
            <h4>Analysis Summary</h4>
            <div class="summary-stats">
                <div class="stat-item">
                    <span class="stat-value">${result.total_images}</span>
                    <span class="stat-label">Images Analyzed</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">${result.total_defects}</span>
                    <span class="stat-label">Total Defects</span>
                </div>
            </div>
        </div>
    `;
    
    // Create individual image results with thumbnails
    const imageResultsHTML = result.results.map((imageResult, index) => `
        <div class="image-result-card" id="imageResult_${index}">
            <div class="image-result-header">
                <h5>üì∑ ${imageResult.filename}</h5>
                <span class="defect-count-badge">${imageResult.defect_count} defects</span>
            </div>
            
            ${imageResult.annotated_image ? `
                <div class="image-preview-container">
                    <img src="${imageResult.annotated_image}" 
                         alt="Annotated ${imageResult.filename}"
                         class="annotated-preview-image"
                         onclick="showFullImage('${imageResult.annotated_image}', '${imageResult.filename}')"
                         style="cursor: pointer; max-width: 100%; height: 200px; object-fit: cover; border-radius: 8px;">
                    <div class="image-overlay">
                        <span class="click-to-expand">üîç Click to expand</span>
                    </div>
                </div>
            ` : '<div class="no-image">No annotated image available</div>'}
            
            <div class="defects-list">
                ${imageResult.defects && imageResult.defects.length > 0 ? 
                    imageResult.defects.map(defect => `
                        <div class="defect-item-small">
                            <span class="defect-type">${defect.type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</span>
                            <span class="defect-confidence">${(defect.confidence * 100).toFixed(1)}%</span>
                            <span class="severity-badge severity-${getSeverityLevel(defect.type, result.detection_type)}">
                                ${getSeverityLevel(defect.type, result.detection_type)}
                            </span>
                        </div>
                    `).join('') 
                    : '<div class="no-defects">‚úÖ No defects detected</div>'
                }
            </div>
        </div>
    `).join('');
    
    // Overall defect summary
    const defectSummaryHTML = `
        <div class="defect-summary">
            <h4>Overall Defect Summary</h4>
            ${Object.entries(result.defect_summary || {}).map(([type, count]) => `
                <div class="defect-item">
                    <div class="defect-info">
                        <div class="defect-type">${type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
                        <div class="defect-details">Found across ${count} occurrence(s)</div>
                    </div>
                    <div class="defect-count">
                        <div class="count-number">${count}</div>
                        <div class="severity-badge severity-${getSeverityLevel(type, result.detection_type)}">
                            ${getSeverityLevel(type, result.detection_type)}
                        </div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
    
    // Add necessary CSS styles
    if (!document.getElementById('multiImageResultsStyle')) {
        const style = document.createElement('style');
        style.id = 'multiImageResultsStyle';
        style.textContent = `
            .multi-results-summary { margin-bottom: 2rem; padding: 1.5rem; background: var(--gray-50); border-radius: var(--radius-lg); }
            .multi-results-summary h4 { margin-bottom: 1rem; font-weight: 600; }
            .summary-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; }
            .stat-item { text-align: center; padding: 1rem; background: white; border-radius: var(--radius-md); }
            .stat-value { display: block; font-size: 2rem; font-weight: 700; color: var(--primary-main); }
            .stat-label { font-size: 0.875rem; color: var(--gray-600); text-transform: uppercase; }
            
            .image-result-card { 
                background: white; 
                border-radius: 12px; 
                padding: 1.5rem; 
                margin-bottom: 1.5rem; 
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                border: 1px solid #e5e7eb;
            }
            .image-result-header { 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                margin-bottom: 1rem; 
                padding-bottom: 0.75rem;
                border-bottom: 1px solid #e5e7eb;
            }
            .image-result-header h5 { margin: 0; font-size: 1.125rem; font-weight: 600; }
            .defect-count-badge { 
                background: var(--primary-main); 
                color: white; 
                padding: 0.25rem 0.75rem; 
                border-radius: 20px; 
                font-size: 0.875rem; 
                font-weight: 600; 
            }
            
            .image-preview-container { 
                position: relative; 
                margin-bottom: 1rem; 
                border-radius: 8px;
                overflow: hidden;
                background: #f9fafb;
            }
            .image-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.7);
                color: white;
                padding: 0.5rem 1rem;
                border-radius: 20px;
                opacity: 0;
                transition: opacity 0.3s;
                pointer-events: none;
                font-size: 0.875rem;
                font-weight: 600;
            }
            .image-preview-container:hover .image-overlay {
                opacity: 1;
            }
            .annotated-preview-image:hover {
                opacity: 0.8;
                transition: opacity 0.3s;
            }
            
            .defects-list { display: flex; flex-direction: column; gap: 0.5rem; }
            .defect-item-small { 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                padding: 0.75rem; 
                background: #f8fafc; 
                border-radius: 8px; 
                border-left: 4px solid var(--primary-main);
            }
            .defect-type { font-weight: 600; }
            .defect-confidence { font-size: 0.875rem; color: var(--gray-600); }
            .no-defects { 
                text-align: center; 
                padding: 2rem; 
                color: var(--success); 
                font-weight: 600; 
                background: #f0fdf4;
                border-radius: 8px;
            }
            .no-image { 
                text-align: center; 
                padding: 2rem; 
                color: var(--gray-500); 
                background: #f9fafb;
                border-radius: 8px;
                margin-bottom: 1rem;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Combine all HTML
    defectList.innerHTML = summaryHTML + imageResultsHTML + defectSummaryHTML;
    
    // Update session results
    sessionResults.push(...(result.results || []).flatMap(r => r.defects || []));
}

// ADDED: Function to show full-size image in modal
function showFullImage(base64Image, filename) {
    // Create or update full image modal
    let fullImageModal = document.getElementById('fullImageModal');
    if (!fullImageModal) {
        fullImageModal = document.createElement('div');
        fullImageModal.id = 'fullImageModal';
        fullImageModal.innerHTML = `
            <div class="full-image-overlay" onclick="closeFullImage()">
                <div class="full-image-container" onclick="event.stopPropagation()">
                    <div class="full-image-header">
                        <h3 id="fullImageTitle"></h3>
                        <button onclick="closeFullImage()" class="close-full-image">‚úï</button>
                    </div>
                    <img id="fullImage" src="" alt="Full size annotated image">
                    <div class="full-image-actions">
                        <button onclick="downloadFullImage()" class="btn btn-primary">Download Image</button>
                    </div>
                </div>
            </div>
        `;
        
        // Add full image modal styles
        const style = document.createElement('style');
        style.textContent = `
            #fullImageModal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 1003;
                display: none;
            }
            .full-image-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2rem;
            }
            .full-image-container {
                background: white;
                border-radius: 12px;
                max-width: 90vw;
                max-height: 90vh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            .full-image-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid #e5e7eb;
            }
            .full-image-header h3 {
                margin: 0;
                font-size: 1.25rem;
                font-weight: 600;
            }
            .close-full-image {
                background: none;
                border: none;
                font-size: 1.5rem;
                cursor: pointer;
                color: #6b7280;
                padding: 0.5rem;
                border-radius: 4px;
            }
            .close-full-image:hover {
                background: #f3f4f6;
                color: #374151;
            }
            #fullImage {
                max-width: 100%;
                max-height: calc(90vh - 120px);
                object-fit: contain;
            }
            .full-image-actions {
                padding: 1rem;
                border-top: 1px solid #e5e7eb;
                text-align: right;
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(fullImageModal);
    }
    
    document.getElementById('fullImageTitle').textContent = `Annotated: ${filename}`;
    document.getElementById('fullImage').src = base64Image;
    fullImageModal.style.display = 'block';
    
    // Store current image for download
    window.currentFullImage = { base64: base64Image, filename: filename };
}

function closeFullImage() {
    document.getElementById('fullImageModal').style.display = 'none';
}

function downloadFullImage() {
    if (window.currentFullImage) {
        const link = document.createElement('a');
        link.download = `annotated_${window.currentFullImage.filename}`;
        link.href = window.currentFullImage.base64;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

function displayLiveResults() {
    // Get recent detections (last 10)
    const recentDetections = sessionResults.slice(-10);
    const defectCounts = {};

    // Count detections per type
    recentDetections.forEach(detection => {
        defectCounts[detection.type] = (defectCounts[detection.type] || 0) + 1;
    });

    const defectList = document.getElementById('defectList');
    if (Object.keys(defectCounts).length === 0) {
        defectList.innerHTML = `
            <div class="empty-state">
                üü¢ No defects detected in live stream
            </div>`;
        return;
    }

    const liveHTML = `
        <div class="live-results-header">
            <h4>Live Detection Results</h4>
            <span class="live-indicator">üî¥ LIVE</span>
        </div>
        ${recentDetections.map(d => `
            <div class="defect-item">
                <div class="defect-info">
                    <div class="defect-type">${d.type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</div>
                    <div class="defect-details">Confidence: ${(d.confidence * 100).toFixed(1)}%</div>
                    <div class="defect-location">Detected at: ${new Date(d.timestamp).toLocaleTimeString()}</div>
                </div>
                <div class="defect-count">
                    <div class="count-number">${defectCounts[d.type]}</div>
                    <div class="severity-badge severity-${getSeverityLevel(d.type, currentDetectionType)}">
                        ${getSeverityLevel(d.type, currentDetectionType).toUpperCase()}
                    </div>
                </div>
                ${d.frame_snapshot ? `
                    <div class="defect-preview">
                        <img src="data:image/jpeg;base64,${d.frame_snapshot}" 
                             alt="${d.type}" class="defect-snapshot"
                             onclick="showDefectSnapshot('${d.frame_snapshot}', '${d.type}')"
                             title="Click to enlarge">
                    </div>
                ` : ''}
            </div>
        `).join('')}
    `;

    defectList.innerHTML = liveHTML;

    // Add live results styles (only once)
    if (!document.getElementById('liveResultsStyle')) {
        const style = document.createElement('style');
        style.id = 'liveResultsStyle';
        style.textContent = `
            .live-results-header { 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                margin-bottom: 1rem; 
            }
            .live-results-header h4 { 
                margin: 0; 
                font-weight: 600; 
            }
            .live-indicator { 
                background: var(--error); 
                color: white; 
                padding: 0.25rem 0.5rem; 
                border-radius: var(--radius-full); 
                font-size: 0.75rem; 
                font-weight: 600; 
                animation: pulse 2s infinite; 
            }
        `;
        document.head.appendChild(style);
    }
}

// Missing utility functions
function getSeverityLevel(defectType, detectionType) {
    const severityMap = {
        weld: {
            'Crack': 'high',
            'Burn Through': 'high',
            'Lack of Fusion': 'high',
            'Porosity': 'medium',
            'Undercut': 'medium',
            'Spatter': 'low',
            'Arc strike': 'low',
            'Excess-Reinforcement': 'medium',
            'Irregular': 'medium',
            'Overlap': 'medium',
            'excess root penetration': 'medium',
            'mechanical-damage': 'high',
            'root concvity': 'medium',
            'slag-inclusion': 'medium'
        },
        coating: {
            'crack': 'high',
            'Peel Off': 'high',
            'Blister': 'medium',
            'Wrinkle': 'medium',
            'Paint sagging': 'medium',
            'Orange Peel': 'low',
            'chalking': 'low',
            'cratering': 'medium',
            'rash': 'low'
        },
        flange: {
            'Flange_pass': 'low',
            'Flange_fail': 'high',
            'Flange_unknown': 'medium'
        }
    };
    
    return severityMap[detectionType]?.[defectType] || 'medium';
}

function showPreviewImage(base64Image) {
    const previewImg = document.getElementById('previewImage');
    // Ensure base64 string has data URI prefix
    if (!base64Image.startsWith('data:')) {
        previewImg.src = `data:image/jpeg;base64,${base64Image}`;
    } else {
        previewImg.src = base64Image;
    }

    previewImg.classList.remove('hidden');

    document.getElementById('placeholder').style.display = 'none';
    document.getElementById('video').style.display = 'none';
    document.getElementById('canvas').style.display = 'none';
}

function showVideoDownloadOption(videoUrl) {
    const detectionArea = document.querySelector('.detection-area');
    
    // Remove existing download button if present
    const existingButton = detectionArea.querySelector('.video-download-btn');
    if (existingButton) {
        existingButton.remove();
    }
    
    const downloadButton = document.createElement('button');
    downloadButton.className = 'video-download-btn btn btn-primary';
    downloadButton.style.marginTop = '1rem';
    downloadButton.innerHTML = 'üìπ Download Annotated Video';
    downloadButton.onclick = () => {
        window.open(videoUrl, '_blank');
    };
    
    detectionArea.appendChild(downloadButton);
}

// Status update functions
function showProcessingStatus(message) {
    updateStatus('processing', message);
}

function showActiveStatus(message) {
    updateStatus('active', message);
}

function showSuccessStatus(message) {
    updateStatus('ready', message);
}

function showErrorStatus(message) {
    updateStatus('error', message);
}

function showReadyStatus() {
    updateStatus('ready', '‚ö°Ready to Start Analysis');
}

function updateStatus(type, message) {
    const statusIndicator = document.getElementById('cameraStatus');
    statusIndicator.className = `status-indicator status-${type}`;
    statusIndicator.innerHTML = `<span>${getStatusIcon(type)}</span>${message}`;
}

function getStatusIcon(type) {
    const icons = {
        ready: '‚ö°',
        active: 'üü¢',
        processing: '‚è≥',
        error: '‚ùå'
    };
    return icons[type] || '‚ö°';
}

// Export functions
async function exportCSV() {
    try {
        const response = await fetch(`${API_BASE_URL}/export_csv?type=${currentDetectionType}`, {
            method: 'GET'
        });
        
        if (response.ok) {
            const blob = await response.blob();
            downloadFile(blob, `${currentDetectionType}_defects.csv`);
            showNotification('CSV exported successfully', 'success');
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        console.error('CSV export error:', error);
        showNotification('Failed to export CSV', 'error');
    }
}

async function exportExcel() {
    try {
        const response = await fetch(`${API_BASE_URL}/export_excel?type=${currentDetectionType}`, {
            method: 'GET'
        });
        
        if (response.ok) {
            const blob = await response.blob();
            downloadFile(blob, `${currentDetectionType}_defects.xlsx`);
            showNotification('Excel exported successfully', 'success');
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        console.error('Excel export error:', error);
        showNotification('Failed to export Excel', 'error');
    }
}

async function exportPDF() {
    try {
        showNotification('Generating report...', 'info');
        
        const response = await fetch(`${API_BASE_URL}/export_pdf?type=${currentDetectionType}`, {
            method: 'GET'
        });
        
        // ‚úÖ FIX: Don't parse as JSON on error - check status first
        if (!response.ok) {
            const contentType = response.headers.get('content-type');
            let errorMessage = 'Report generation failed';
            
            // Only try to parse JSON if content-type is JSON
            if (contentType && contentType.includes('application/json')) {
                try {
                    const error = await response.json();
                    errorMessage = error.error || errorMessage;
                } catch (e) {
                    errorMessage = `Server error ${response.status}`;
                }
            } else {
                errorMessage = `Server error ${response.status}: ${response.statusText}`;
            }
            throw new Error(errorMessage);
        }
        
        // ‚úÖ Get the HTML blob (not JSON!)
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        
        // Open in new window
        const reportWindow = window.open(url, '_blank');
        
        if (!reportWindow) {
            // Fallback: download the file
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentDetectionType}_report_${Date.now()}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            showNotification('Report downloaded! Open it and use Print > Save as PDF', 'success');
        } else {
            showNotification('Report opened! Use Print > Save as PDF', 'success');
        }
        
    } catch (error) {
        console.error('PDF export error:', error);
        showNotification('Failed to generate report: ' + error.message, 'error');
    }
}

function generateReportData() {
    // Ensure we have data to work with
    if (!sessionResults || sessionResults.length === 0) {
        console.warn('No session results available for report generation');
        return {
            detectionType: currentDetectionType || 'unknown',
            totalDefects: 0,
            defectTypes: 0,
            defectCounts: {},
            timestamp: new Date().toLocaleString(),
            selectedStandard: selectedStandard || 'N/A',
            sessionId: session_id || 'N/A'
        };
    }
    
    const defectCounts = {};
    sessionResults.forEach(result => {
        const defectType = result.type || 'Unknown';
        defectCounts[defectType] = (defectCounts[defectType] || 0) + 1;
    });
    
    console.log('Report data generated:', {
        totalDefects: sessionResults.length,
        defectTypes: Object.keys(defectCounts).length,
        defectCounts: defectCounts
    });
    
    return {
        detectionType: currentDetectionType || 'unknown',
        totalDefects: sessionResults.length,
        defectTypes: Object.keys(defectCounts).length,
        defectCounts: defectCounts,
        timestamp: new Date().toLocaleString(),
        selectedStandard: selectedStandard || 'N/A',
        sessionId: session_id || new Date().toISOString()
    };
}

function generateReportHTML(data) {
    // Check if we have defects to report
    if (!data.defectCounts || Object.keys(data.defectCounts).length === 0) {
        const noDataRows = `
            <tr>
                <td colspan="3" style="text-align: center; padding: 2rem; color: #6b7280;">
                    No defects detected in this session
                </td>
            </tr>
        `;
        
        return generateReportTemplate(data, noDataRows);
    }
    
    // Generate defect rows
    const defectRows = Object.entries(data.defectCounts).map(([type, count]) => {
        const severity = getSeverityLevel(type, data.detectionType);
        const severityColor = severity === 'high' ? '#ef4444' : 
                              severity === 'medium' ? '#f59e0b' : '#10b981';
        
        return `
        <tr>
            <td>${type.replace(/[_-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</td>
            <td style="text-align: center;">${count}</td>
            <td style="text-align: center;">
                <span style="background: ${severityColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600;">
                    ${severity.toUpperCase()}
                </span>
            </td>
        </tr>
        `;
    }).join('');

    return generateReportTemplate(data, defectRows);
}

function generateReportTemplate(data, defectRows) {
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>RICI Industries - Defect Detection Report</title>
            <style>
                @page {
                    size: A4;
                    margin: 20mm;
                }
                body { 
                    font-family: 'Segoe UI', Arial, sans-serif;
                    margin: 0;
                    padding: 20px;
                    color: #1f2937;
                    line-height: 1.6;
                }
                .header { 
                    text-align: center;
                    margin-bottom: 40px;
                    padding-bottom: 20px;
                    border-bottom: 3px solid #2563eb;
                }
                .company-logo {
                    width: 80px;
                    height: 80px;
                    background: linear-gradient(135deg, #2563eb, #1a365d);
                    border-radius: 12px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: 700;
                    font-size: 28px;
                    margin-bottom: 15px;
                }
                .company-name { 
                    font-size: 32px;
                    font-weight: bold;
                    color: #2563eb;
                    margin: 10px 0;
                }
                .report-title { 
                    font-size: 24px;
                    margin: 15px 0;
                    color: #374151;
                    font-weight: 600;
                }
                .report-subtitle {
                    color: #6b7280;
                    font-size: 14px;
                }
                .summary { 
                    background: #f3f4f6;
                    padding: 20px;
                    border-radius: 8px;
                    margin: 25px 0;
                    border-left: 4px solid #2563eb;
                }
                .summary h3 {
                    margin-top: 0;
                    color: #1f2937;
                    font-size: 18px;
                }
                .summary p {
                    margin: 8px 0;
                    font-size: 14px;
                }
                .summary strong {
                    color: #374151;
                    font-weight: 600;
                }
                .defect-table { 
                    width: 100%;
                    border-collapse: collapse;
                    margin: 25px 0;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }
                .defect-table thead {
                    background: linear-gradient(135deg, #2563eb, #1e40af);
                }
                .defect-table th {
                    color: white;
                    padding: 12px;
                    text-align: left;
                    font-weight: 600;
                    font-size: 14px;
                }
                .defect-table td {
                    border: 1px solid #e5e7eb;
                    padding: 10px 12px;
                    font-size: 13px;
                }
                .defect-table tbody tr:nth-child(even) {
                    background: #f9fafb;
                }
                .defect-table tbody tr:hover {
                    background: #f3f4f6;
                }
                .footer { 
                    text-align: center;
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 2px solid #e5e7eb;
                    font-size: 12px;
                    color: #6b7280;
                }
                .footer p {
                    margin: 5px 0;
                }
                @media print {
                    body { padding: 0; }
                    .header { page-break-after: avoid; }
                    .defect-table { page-break-inside: avoid; }
                }
            </style>
        </head>
        <body>
            <div class="header">
                <div class="company-logo">RICI</div>
                <div class="company-name">RICI Industries</div>
                <div class="report-title">AI Defect Detection Report</div>
                <div class="report-subtitle">Generated: ${data.timestamp}</div>
            </div>
            
            <div class="summary">
                <h3>üìä Analysis Summary</h3>
                <p><strong>Detection Type:</strong> ${data.detectionType.charAt(0).toUpperCase() + data.detectionType.slice(1)}</p>
                <p><strong>Total Defects Found:</strong> ${data.totalDefects}</p>
                <p><strong>Unique Defect Types:</strong> ${data.defectTypes}</p>
                ${data.selectedStandard && data.selectedStandard !== 'N/A' ? `<p><strong>Flange Standard:</strong> ${data.selectedStandard}</p>` : ''}
                <p><strong>Session ID:</strong> ${data.sessionId}</p>
            </div>
            
            <h3 style="color: #374151; margin-top: 30px;">Defect Details</h3>
            <table class="defect-table">
                <thead>
                    <tr>
                        <th>Defect Type</th>
                        <th style="text-align: center;">Count</th>
                        <th style="text-align: center;">Severity</th>
                    </tr>
                </thead>
                <tbody>
                    ${defectRows}
                </tbody>
            </table>
            
            <div class="footer">
                <p><strong>RICI Industries AI Defect Detection System</strong></p>
                <p>This report contains automated analysis results and should be reviewed by qualified personnel.</p>
                <p>¬© ${new Date().getFullYear()} RICI Industries. All rights reserved.</p>
            </div>
        </body>
        </html>
    `;
}


function downloadFile(blob, filename) {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
}

/////new added check
function clearLiveResults() {
    const defectList = document.getElementById('defectList');
    if (defectList) defectList.innerHTML = '';

    //const canvas = document.getElementById('canvas');
    //if (canvas) canvas.style.display = 'none';

    //const video = document.getElementById('video');
    //if (video) video.style.display = 'none';

    console.log('Live results cleared');
}

////change above 



// Utility functions
function clearResults() {
    document.getElementById('defectList').innerHTML = '<div class="empty-state">No defects detected yet. Start an analysis to see results here.</div>';
    document.getElementById('insightsContent').textContent = 'AI analysis and recommendations will appear here after detection. The system will provide specific guidance based on detected defects and their severity levels.';
}

function resetDetection() {
    // Stop any active processes
    if (isLiveDetectionActive) {
        stopCamera();
    }
    
    // Clear results
    sessionResults = [];
    clearResults();
    
    // Reset UI
    document.getElementById('fileInput').value = '';
    document.getElementById('previewImage').classList.add('hidden');
    document.getElementById('placeholder').style.display = 'block';
    
    // Clear any video download buttons
    document.querySelectorAll('.video-download-btn').forEach(btn => btn.remove());
    
    showReadyStatus();
    showNotification('Session reset successfully', 'success');
}

function updateInsights(result) {
    const insightsContent = document.getElementById('insightsContent');
    
    let insights = '';
    
    if (currentDetectionType === 'flange' && result.flange_analysis) {
        const compliance = result.flange_analysis.compliance;
        if (compliance.status === 'pass') {
            insights = 'Flange dimensions are within specification tolerance. The component meets the required standards for safe installation and operation.';
        } else if (compliance.status === 'fail') {
            insights = 'Flange dimensions do not meet specification requirements. Review the measurements and consider reworking or replacing the component.';
        } else {
            insights = 'Unable to determine compliance due to missing scale reference or specifications. Ensure ArUco markers are visible and standards are properly configured.';
        }
    } else if (result.defects && result.defects.length > 0) {
        const highSeverityDefects = result.defects.filter(d => getSeverityLevel(d.type, currentDetectionType) === 'high');
        
        if (result.video_info) {
            // Video-specific insights with deduplication context
            const defectDensity = result.video_info.defect_density_per_minute || 0;
            const duration = result.video_info.duration;
            const uniqueDefects = aggregateVideoDefects(result.defects).length;
            const totalDetections = result.defects.length;
            
            if (highSeverityDefects.length > 0) {
                const uniqueHighSeverity = [...new Set(highSeverityDefects.map(d => d.type))];
                insights = `Critical defects detected in video analysis: ${uniqueHighSeverity.join(', ')}. `;
                insights += `Found ${totalDetections} total detections of ${uniqueDefects} unique defect types over ${duration.toFixed(1)} seconds. `;
                insights += `Defect density: ${defectDensity} defects/minute. Immediate attention required.`;
            } else {
                insights = `Video analysis complete: ${totalDetections} total detections of ${uniqueDefects} unique defect types over ${duration.toFixed(1)} seconds. `;
                insights += `Average defect density: ${defectDensity} defects/minute. Most defects are low to medium severity requiring routine maintenance.`;
            }
        } else {
            // Static image insights
            if (highSeverityDefects.length > 0) {
                const uniqueHighSeverity = [...new Set(highSeverityDefects.map(d => d.type))];
                insights = `Critical defects detected: ${uniqueHighSeverity.join(', ')}. Immediate attention required to prevent structural failure or safety issues.`;
            } else {
                const totalDefects = result.defects.length;
                insights = `${totalDefects} defect${totalDefects > 1 ? 's' : ''} detected. Most are low to medium severity. Regular monitoring and maintenance recommended.`;
            }
        }
    } else {
        insights = 'No significant defects detected. The component appears to meet quality standards based on current analysis.';
    }
    
    insightsContent.textContent = insights;
}


function showNotification(message, type = 'info') {
    // Create notification if it doesn't exist
    let notification = document.getElementById('notification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'notification';
        notification.style.cssText = `
            position: fixed;
            top: 5rem;
            right: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 600;
            z-index: 1002;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        `;
        document.body.appendChild(notification);
    }
    
    // Set color based on type
    const colors = {
        success: '#10b981',
        error: '#ef4444',
        warning: '#f59e0b',
        info: '#2563eb'
    };
    
    notification.style.background = colors[type] || colors.info;
    notification.textContent = message;
    
    // Show notification
    notification.style.transform = 'translateX(0)';
    
    // Hide after 4 seconds
    setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
    }, 4000);
}













// Check authentication on page load
document.addEventListener('DOMContentLoaded', function() {
    initializeElements();
    checkAuthentication();
    checkBackendConnection();
    loadFlangeStandards();
    
    // Check backend connection every 30 seconds
    setInterval(checkBackendConnection, 30000);
});

// Check if user is authenticated
async function checkAuthentication() {
    const token = localStorage.getItem('rici_token');
    const user = localStorage.getItem('rici_user');
    
    if (!token || !user) {
        showAuthModal();
        return;
    }
    
    // Verify token with backend
    try {
        const response = await fetch(`${API_BASE_URL}/auth/verify`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            currentUser = result.user;
            authToken = token;
            showUserProfile(result.user);
            hideAuthModal();
        } else {
            // Token invalid - clear and show login
            clearAuthData();
            showAuthModal();
        }
    } catch (error) {
        console.error('Auth verification error:', error);
        showAuthModal();
    }
}

// Show authentication modal
function showAuthModal() {
    // Create auth modal if it doesn't exist
    let authModal = document.getElementById('authModal');
    if (!authModal) {
        authModal = document.createElement('div');
        authModal.id = 'authModal';
        authModal.innerHTML = `
               <div class="auth-overlay">
                 <div class="auth-container"> 
                    <div class="auth-header">
                         <div class="auth-logo">RICI</div>
                          <h2>RICI Industries</h2> 
                          <p>AI Powered Inspection System</p>
                           </div>
   

                    
                    <div class="auth-tabs">
                        <button class="auth-tab active" onclick="switchAuthTab('login')">Login</button>
                        <button class="auth-tab" onclick="switchAuthTab('register')">Register</button>
                    </div>
                    
                    <div id="authMessage" class="auth-message"></div>
                    
                    <!-- Login Form -->
                    <form id="loginForm" class="auth-form active" onsubmit="handleLoginSubmit(event)">
                        <div class="form-group">
                            <label>üìß Email</label>
                            <input type="email" id="loginEmail" required placeholder="your.email@company.com">
                        </div>
                        <div class="form-group">
                            <label>üîí Password</label>
                            <input type="password" id="loginPassword" required placeholder="Enter password">
                        </div>
                        <button type="submit" class="btn btn-primary">Sign In</button>
                    </form>
                    
                    <!-- Register Form -->
                    <form id="registerForm" class="auth-form" onsubmit="handleRegisterSubmit(event)">
                        <div class="form-group">
                            <label>üë§ Full Name</label>
                            <input type="text" id="registerName" required placeholder="John Doe">
                        </div>
                        <div class="form-group">
                            <label>üìß Email</label>
                            <input type="email" id="registerEmail" required placeholder="john.doe@company.com">
                        </div>
                        <div class="form-group">
                            <label>üîí Password</label>
                            <input type="password" id="registerPassword" required minlength="8" placeholder="Min. 8 characters">
                        </div>
                        <div class="form-group">
                            <label>üè¢ Department</label>
                            <select id="registerDepartment">
                                <option>Quality Control</option>
                                <option>Production</option>
                                <option>Maintenance</option>
                                <option>Engineering</option>
                                <option>Inspection</option>
                            </select>
                        </div>
                        <button type="submit" class="btn btn-primary">Create Account</button>
                    </form>
                </div>
            </div>
        `;
        
        // Add auth modal styles
        const style = document.createElement('style');
        style.textContent = `
            #authModal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            #authModal.hidden {
                display: none;
            }
            .auth-overlay {
                padding: 2rem;
                max-width: 500px;
                width: 100%;
            }
            .auth-container {
                background: white;
                border-radius: 20px;
                overflow: hidden;
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            }
            .auth-header {
                background: linear-gradient(135deg, #2563eb, #1a365d);
                color: white;
                padding: 2rem;
                text-align: center;
            }
            .auth-logo {
                width: 80px;
                height: 80px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 2rem;
                font-weight: bold;
                margin-bottom: 1rem;
                border: 3px solid white;
            }
            .auth-header h2 {
                margin: 0.5rem 0;
                font-size: 1.5rem;
            }
            .auth-header p {
                margin: 0;
                opacity: 0.9;
                font-size: 0.9rem;
            }
            .auth-tabs {
                display: flex;
                padding: 0 2rem;
                gap: 1rem;
                margin-top: 1rem;
            }
            .auth-tab {
                flex: 1;
                padding: 0.75rem;
                background: #f3f4f6;
                border: none;
                border-radius: 10px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
            }
            .auth-tab.active {
                background: linear-gradient(135deg, #2563eb, #1a365d);
                color: white;
            }
            .auth-form {
                display: none;
                padding: 2rem;
            }
            .auth-form.active {
                display: block;
            }
            .form-group {
                margin-bottom: 1.5rem;
            }
            .form-group label {
                display: block;
                margin-bottom: 0.5rem;
                font-weight: 600;
                color: #374151;
            }
            .form-group input,
            .form-group select {
                width: 100%;
                padding: 0.875rem;
                border: 2px solid #e5e7eb;
                border-radius: 10px;
                font-size: 1rem;
                transition: border-color 0.3s;
            }
            .form-group input:focus,
            .form-group select:focus {
                outline: none;
                border-color: #2563eb;
            }
            .auth-message {
                margin: 1rem 2rem;
                padding: 0.75rem;
                border-radius: 8px;
                text-align: center;
                font-weight: 500;
                display: none;
            }
            .auth-message.error {
                background: #fee2e2;
                color: #991b1b;
                display: block;
            }
            .auth-message.success {
                background: #d1fae5;
                color: #065f46;
                display: block;
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(authModal);
    }
    
    authModal.classList.remove('hidden');
}

function hideAuthModal() {
    const authModal = document.getElementById('authModal');
    if (authModal) {
        authModal.classList.add('hidden');
    }
}

// Switch between login and register tabs
function switchAuthTab(tab) {
    document.querySelectorAll('.auth-tab').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
    
    if (tab === 'login') {
        document.querySelector('.auth-tab:first-child').classList.add('active');
        document.getElementById('loginForm').classList.add('active');
    } else {
        document.querySelector('.auth-tab:last-child').classList.add('active');
        document.getElementById('registerForm').classList.add('active');
    }
    hideAuthMessage();
}

// Handle login submission
async function handleLoginSubmit(event) {
    event.preventDefault();
    
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    
    try {
        const response = await fetch(`${API_BASE_URL}/auth/login`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, password })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Store credentials
            localStorage.setItem('rici_token', result.session_id);
            localStorage.setItem('rici_user', JSON.stringify(result.user));
            
            currentUser = result.user;
            authToken = result.session_id;
            
            showAuthMessage('‚úÖ Login successful!', 'success');
            
            // Show user profile and hide modal
            setTimeout(() => {
                showUserProfile(result.user);
                hideAuthModal();
            }, 1000);
        } else {
            showAuthMessage(result.error || 'Login failed', 'error');
        }
    } catch (error) {
        console.error('Login error:', error);
        showAuthMessage('Connection error. Please check if backend is running.', 'error');
    }
}

// Handle register submission
async function handleRegisterSubmit(event) {
    event.preventDefault();
    
    const name = document.getElementById('registerName').value;
    const email = document.getElementById('registerEmail').value;
    const password = document.getElementById('registerPassword').value;
    const department = document.getElementById('registerDepartment').value;
    
    try {
        const response = await fetch(`${API_BASE_URL}/auth/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                full_name: name,
                email: email,
                password: password,
                department: department
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showAuthMessage(`‚úÖ Account created! Your Job ID: ${result.user.job_id}`, 'success');
            
            // Switch to login tab after 2 seconds
            setTimeout(() => {
                switchAuthTab('login');
                document.getElementById('loginEmail').value = email;
            }, 2000);
        } else {
            showAuthMessage(result.error || 'Registration failed', 'error');
        }
    } catch (error) {
        console.error('Registration error:', error);
        showAuthMessage('Connection error. Please check if backend is running.', 'error');
    }
}

// Show user profile in header
function showUserProfile(user) {
    // Remove any existing user profile
    let userProfile = document.getElementById('userProfile');
    if (userProfile) {
        userProfile.remove();
    }
    
    // Create new user profile element
    userProfile = document.createElement('div');
    userProfile.id = 'userProfile';
    userProfile.innerHTML = `
        <div class="user-avatar">${user.full_name.charAt(0).toUpperCase()}</div>
        <div class="user-info">
            <div class="user-name">${user.full_name}</div>
            <div class="user-job-id">${user.job_id}</div>
        </div>
        <button onclick="handleLogoutClick()" class="logout-btn">Logout</button>
    `;
    
    // Add user profile styles if not already added
    if (!document.getElementById('userProfileStyles')) {
        const style = document.createElement('style');
        style.id = 'userProfileStyles';
        style.textContent = `
            #userProfile {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                padding: 0.5rem 1rem;
                background: white;
                border-radius: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
            .user-avatar {
                width: 40px;
                height: 40px;
                background: linear-gradient(135deg, #2563eb, #1a365d);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                font-size: 1.125rem;
            }
            .user-info {
                display: flex;
                flex-direction: column;
            }
            .user-name {
                font-weight: 600;
                color: #374151;
                font-size: 0.875rem;
            }
            .user-job-id {
                font-size: 0.75rem;
                color: #6b7280;
            }
            .logout-btn {
                padding: 0.5rem 1rem;
                background: #ef4444;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.875rem;
                font-weight: 600;
                transition: all 0.2s;
            }
            .logout-btn:hover {
                background: #dc2626;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add to nav status area
    const navStatus = document.querySelector('.nav-status');
    if (navStatus) {
        navStatus.appendChild(userProfile);
    }
}

// Handle logout
async function handleLogoutClick() {
    try {
        if (authToken) {
            await fetch(`${API_BASE_URL}/auth/logout`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${authToken}`
                }
            });
        }
    } catch (error) {
        console.error('Logout error:', error);
    }
    
    // Clear auth data
    clearAuthData();
    
    // Show auth modal
    showAuthModal();
    
    // Clear any active sessions/results
    resetDetection();
}

// Clear authentication data
function clearAuthData() {
    localStorage.removeItem('rici_token');
    localStorage.removeItem('rici_user');
    currentUser = null;
    authToken = null;
    
    // Remove user profile display
    const userProfile = document.getElementById('userProfile');
    if (userProfile) {
        userProfile.remove();
    }
}

// Show/hide auth messages
function showAuthMessage(text, type) {
    const messageEl = document.getElementById('authMessage');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = `auth-message ${type}`;
    }
}

function hideAuthMessage() {
    const messageEl = document.getElementById('authMessage');
    if (messageEl) {
        messageEl.className = 'auth-message';
    }
}

// ==================== END AUTHENTICATION SYSTEM ====================


















    </script>
    </body>
</html>
</body>
</html>
